<html lang="en">
 <head>
    <meta property="og:title" content="Stupid World" />
    <meta property="og:description" content="Create your V2Ray account effortlessly and experience a secure, anonymous internet connection. Protect your privacy and enjoy unrestricted access to content from anywhere in the world." />
    <meta property="og:url" content="https://vpn.stupidworld.web.id/" />
    <meta property="og:type" content="website" />

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="VLESS VMESS TROJAN SHADOESOCKS" />
    <meta name="twitter:description" content="Create your V2Ray account effortlessly and experience a secure, anonymous internet connection. Protect your privacy and enjoy unrestricted access to content from anywhere in the world." />
    <meta name="twitter:url" content="https://benxx.dpdns.org/" />
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <title>
   BENXX - PROJECT
  </title>
  <script src="https://cdn.tailwindcss.com">
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap" rel="stylesheet"/>
    <style>
:root {
    --color-bg: #050a18;
    --color-bg-card: #0a1128;
    --color-primary: #00ddff;
    --color-secondary: #7700ff;
    --color-accent: #ff00aa;
    --color-text: #e0f7ff;
    --color-text-dim: #8ba3b8;
    --color-success: #00ffaa;
    --color-error: #ff2266;
    --color-input-bg: rgba(0, 221, 255, 0.05);
    --color-input-border: rgba(0, 221, 255, 0.2);
    --glow-primary: 0 0 10px rgba(0, 221, 255, 0.5), 0 0 20px rgba(0, 221, 255, 0.2);
    --glow-secondary: 0 0 10px rgba(119, 0, 255, 0.5), 0 0 20px rgba(119, 0, 255, 0.2);
    --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    --card-width: 100%;
    --card-max-width: 480px;
    --card-padding: 1.5rem;
    --card-border-radius: 12px;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --color-bg: #0f0f0f; /* terminal dark */
    --color-grid: #00ff00; /* neon green */
    --color-text: #00ff00;
    --color-accent: #00cc00;
    --card-width: 100%;
    --card-max-width: 720px;
    --font-mono: 'Courier New', Courier, monospace;
}

body {
    background-color: var(--color-bg);
    color: var(--color-text);
    font-family: var(--font-mono);
    margin: 0;
    padding: 0;
    line-height: 1.5;
    overflow-x: hidden;
}

body::before {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(90deg, var(--color-grid) 1px, transparent 1%) center,
        linear-gradient(var(--color-grid) 1px, transparent 1%) center;
    background-size: 22px 22px;
    background-color: transparent;
    opacity: 0.05;
    z-index: -1;
}

.container {
    width: var(--card-width);
    max-width: var(--card-max-width);
    padding: 1rem;
    margin: 1rem auto;
    background-color: rgba(0, 255, 0, 0.05);
    border: 1px solid var(--color-accent);
    border-radius: 8px;
    box-shadow: 0 0 10px #00ff00aa;
}

:root {
    --color-bg: #0d0d0d;
    --color-bg-card: #111;
    --color-text: #00ff00;
    --color-accent: #00cc00;
    --card-border-radius: 6px;
    --card-padding: 1rem;
    --card-glow: 0 0 10px #00ff00;
}

body {
    background-color: var(--color-bg);
    color: var(--color-text);
    font-family: 'Courier New', Courier, monospace;
    margin: 0;
    padding: 0;
}

.card {
    background: var(--color-bg-card);
    border-radius: var(--card-border-radius);
    padding: var(--card-padding);
    box-shadow: var(--card-glow);
    border: 1px solid rgba(0, 255, 0, 0.1);
    color: var(--color-text);
    width: 100%;
    position: relative;
    overflow: hidden;
}

.card::before,
.footer::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    height: 2px;
    width: 100%;
    background: linear-gradient(90deg, #00ff00, #00cc00, #009900);
    opacity: 0.3;
}

.card::after,
.footer::after {
    content: "";
    position: absolute;
    top: 2px;
    left: 0;
    width: 100%;
    height: 1px;
    background: #00ff0055;
    filter: blur(1px);
    opacity: 0.2;
}

/* Title container and text with Matrix/Hacker theme */
.title-container {
    text-align: center;
    margin-bottom: 1.5rem;
    position: relative;
}

.title {
    font-family: "Orbitron", sans-serif;
    font-weight: 700;
    font-size: 1.8rem;
    letter-spacing: 1px;
    margin: 0;
    background: linear-gradient(90deg, rgba(0, 255, 0, 0.8), rgba(50, 255, 50, 0.6)); /* Darker green for a more subtle effect */
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    position: relative;
    display: inline-block;
    text-shadow: 0 0 10px rgba(0, 255, 0, 0.6), 0 0 15px rgba(0, 255, 0, 0.4); /* Reduced glow effect for a cleaner look */
}

.title::after {
    content: "";
    position: absolute;
    top: -8px;
    right: -30px;
    font-size: 0.7rem;
    font-weight: 400;
    background: rgba(0, 255, 0, 0.4); /* Slightly darker neon green for subtler effect */
    color: #000000;
    padding: 2px 5px;
    border-radius: 3px;
    -webkit-text-fill-color: #000000;
    transform: rotate(15deg);
    text-shadow: 0 0 10px rgba(0, 255, 0, 0.7), 0 0 15px rgba(0, 255, 0, 0.3); /* Adjusted glow for more realistic look */
    animation: matrix-text 1.5s infinite;
}

/* Keyframes for Matrix-style text effect */
@keyframes matrix-text {
    0% {
        content: "HOME";
    }
    20% {
        content: "CONVERT";
    }
    40% {
        content: "SUB";
    }
    60% {
        content: "CHECKER";
    }
    80% {
        content: "GENERATE";
    }
    100% {
        content: "HOME";
    }
}

/* Hidden class for content visibility */
.hidden {
    visibility: hidden;
}

:root {
    --color-bg: #0d0d0d;
    --color-text: #00ff00;
    --color-input-bg: #111;
    --color-input-border: #00ff0055;
    --color-input-focus: #00ff00;
    --glow-primary: 0 0 6px #00ff00;
    --transition: 0.2s ease-in-out;
}

.form-group {
    margin-bottom: 1.2rem;
    position: relative;
}

.form-group label {
    display: block;
    margin-bottom: 0.3rem;
    font-weight: bold;
    font-size: 0.95rem;
    color: var(--color-text);
    letter-spacing: 0.5px;
    font-family: 'Courier New', monospace;
}

.form-control {
    width: 100%;
    padding: 0.7rem 0.8rem;
    background: var(--color-input-bg);
    border: 1px solid var(--color-input-border);
    border-radius: 4px;
    color: var(--color-text);
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
    font-weight: normal;
    transition: var(--transition);
}

.form-control:focus {
    outline: none;
    border-color: var(--color-input-focus);
    box-shadow: var(--glow-primary);
}

select.form-control {
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%2300ff00' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.8rem center;
    background-size: 1rem;
    padding-right: 2.2rem;
}

:root {
    --color-bg: #0d0d0d;
    --color-text: #00ff00;
    --color-btn-bg: #111;
    --color-btn-border: #00ff00;
    --glow-primary: 0 0 10px #00ff00;
    --transition: 0.2s ease-in-out;
}

.btn {
    width: 100%;
    padding: 0.8rem;
    background: var(--color-btn-bg);
    color: var(--color-text);
    border: 1px solid var(--color-btn-border);
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    font-size: 1rem;
    letter-spacing: 1px;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
    overflow: hidden;
    text-transform: uppercase;
}

.btn::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.2), transparent);
    transition: 0.5s;
}

.btn:hover::before {
    left: 100%;
}

.btn:hover {
    box-shadow: var(--glow-primary);
    transform: translateY(-2px);
}

:root {
    --color-bg: #0d0d0d;
    --color-text: #00ff00;
    --color-accent: #00cc00;
    --color-success: #00ff00;
    --glow-primary: 0 0 10px #00ff00;
}

.loading {
    display: none;
    text-align: center;
    margin: 1.5rem 0;
    color: var(--color-text);
    font-family: 'Courier New', monospace;
}

.spinner {
    display: inline-block;
    width: 40px;
    height: 40px;
    border: 3px solid rgba(0, 255, 0, 0.1);
    border-radius: 50%;
    border-top-color: var(--color-text);
    animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.loading-text {
    margin-top: 0.8rem;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    letter-spacing: 1px;
    color: var(--color-text);
}

.result {
    display: none;
    margin-top: 1.5rem;
    position: relative;
    color: var(--color-text);
    font-family: 'Courier New', monospace;
    background: #111;
    border: 1px solid #00ff0044;
    padding: 1rem;
    border-radius: 4px;
    box-shadow: 0 0 6px #00ff0044;
}

.result-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.8rem;
}

.result-title {
    font-size: 1.1rem;
    font-weight: bold;
    color: var(--color-success);
    text-transform: uppercase;
}

:root {
    --color-bg: #0d0d0d;
    --color-text: #00ff00;
    --color-input-border: #00ff00;
    --color-error: #ff0033;
    --glow-primary: 0 0 8px #00ff00;
}

.output-container {
    position: relative;
    margin-bottom: 0.8rem;
}

.output {
    width: 100%;
    height: 180px;
    background: #111;
    border: 1px solid var(--color-input-border);
    border-radius: 4px;
    color: var(--color-text);
    padding: 0.8rem;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
    resize: vertical;
    line-height: 1.4;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.1);
}

.output:focus {
    outline: none;
    border-color: var(--color-input-border);
    box-shadow: var(--glow-primary);
}

.error-message {
    color: var(--color-error);
    text-align: center;
    margin-top: 0.8rem;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    font-weight: bold;
}

/* Responsive adjustments */
@media (max-width: 480px) {
    :root {
        --card-padding: 1.2rem;
    }

    .container {
        padding: 0 0.5rem;
    }

    .title {
        font-size: 1.5rem;
        color: #00ff00;
        font-family: 'Courier New', monospace;
    }

    .subtitle {
        font-size: 0.8rem;
        color: #00ff00;
        font-family: 'Courier New', monospace;
    }

    .form-group label {
        font-size: 0.9rem;
        color: #00ff00;
        font-family: 'Courier New', monospace;
    }

    .form-control {
        padding: 0.6rem 0.7rem;
        font-size: 0.9rem;
        background: #111;
        border: 1px solid #00ff00;
        color: #00ff00;
        font-family: 'Courier New', monospace;
    }

    .btn {
        padding: 0.7rem;
        font-size: 0.9rem;
        font-family: 'Courier New', monospace;
        background: #000;
        color: #00ff00;
        border: 1px solid #00ff00;
        box-shadow: 0 0 6px #00ff00;
    }
}

/* Terminal Hacker Details */
.tech-detail {
    position: absolute;
    background: #00ff00;
    opacity: 0.08;
    z-index: -1;
    pointer-events: none;
}

.tech-detail-1 {
    width: 40px;
    height: 40px;
    top: 20px;
    right: 20px;
    border-radius: 50%;
    box-shadow: 0 0 15px #00ff0055;
    background: #00ff00;
}

.tech-detail-2 {
    width: 80px;
    height: 2px;
    bottom: 40px;
    left: -20px;
    transform: rotate(45deg);
    background: #00ff00;
    box-shadow: 0 0 6px #00ff0044;
}

.tech-detail-3 {
    width: 15px;
    height: 15px;
    bottom: 20px;
    right: 40px;
    transform: rotate(45deg);
    background: #00ff00;
    box-shadow: 0 0 4px #00ff0044;
}

/* Animated typing effect for loading */
.typing {
    overflow: hidden;
    white-space: nowrap;
    border-right: 2px solid #00ff00; /* Hijau neon */
    width: 0;
    animation: typing 3s steps(30, end) infinite;
    color: #00ff00; /* Teks hijau neon */
}

@keyframes typing {
    0% { width: 0 }
    80% { width: 100% }
    100% { width: 100% }
}

/* UUID Generate Button */
.form-group.uuid-group {
    position: relative;
}

.uuid-generate {
    position: absolute;
    right: 8px;
    top: 36px;
    background: #111; /* Latar belakang gelap */
    border: none;
    color: #00ff00; /* Hijau neon */
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.75rem;
    transition: 0.2s;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.2);
}

.uuid-generate:hover {
    background: #222; /* Gelap saat hover */
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
}

/* Form Row */
.form-row {
    display: flex;
    gap: 0.8rem;
    margin-bottom: 1.2rem;
}

.form-row .form-group {
    flex: 1;
    margin-bottom: 0;
}

.info-badge {
    display: inline-block;
    background: var(--color-accent);
    color: var(--color-bg);
    font-size: 0.65rem;
    padding: 1px 5px;
    border-radius: 3px;
    margin-left: 5px;
    vertical-align: middle;
    font-weight: 600;
}

.custom-bug-container {
    display: none;
}

/* Footer styles */
.footer {
  width: 100%;
  max-width: 480px;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 12px;
  padding: 1.5rem;
  position: relative;
  border: 1px solid rgba(0, 255, 0, 0.2);
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  overflow: hidden;
  margin: 0 0.75rem;
  font-family: "Share Tech Mono", monospace;
  color: #00ff9c;
}

.footer::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  height: 3px;
  width: 100%;
  background: linear-gradient(90deg, #00ff9c, #00ffcc, #39ff14);
  animation: glitch-bar 4s infinite linear;
}

.footer::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 0;
  height: 1px;
  width: 100%;
  background: linear-gradient(90deg, #00ff9c, transparent, #39ff14);
  filter: blur(1px);
}

.footer-logo {
  font-size: 1.2rem;
  margin-bottom: 0.4rem;
  background: linear-gradient(90deg, #00ffcc, #39ff14);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  font-family: "Orbitron", sans-serif;
  letter-spacing: 2px;
}

.footer-powered {
  font-size: 0.75rem;
  color: #00ff9c;
  margin-bottom: 0.6rem;
  opacity: 0.8;
}

.footer-social {
  display: flex;
  justify-content: center;
  gap: 0.8rem;
  margin-bottom: 0.6rem;
  flex-wrap: wrap;
}

.social-link {
  color: #00ffcc;
  background: rgba(0, 255, 128, 0.05);
  border: 1px solid rgba(0, 255, 128, 0.2);
  padding: 0.25rem 0.6rem;
  border-radius: 4px;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  font-size: 0.8rem;
}

.social-link:hover {
  background: rgba(0, 255, 128, 0.1);
  box-shadow: 0 0 10px #00ff9c;
  transform: translateY(-1px);
}

.footer-year {
  font-size: 0.75rem;
  color: #39ff14;
  margin-top: 0.5rem;
  letter-spacing: 1px;
}

@keyframes glitch-bar {
  0% { transform: translateX(0); }
  100% { transform: translateX(100%); }
}

/* Matrix / Hacker Circuit Line Effects */
.circuit-line-1,
.circuit-line-2,
.circuit-line-3,
.circuit-line-4 {
  position: absolute;
  background: #00ff9c;
  box-shadow: 0 0 6px #00ff9c, 0 0 10px #00ff9c;
  opacity: 0.2;
  animation: flicker 4s infinite ease-in-out;
}

.circuit-line-1 {
  width: 60px;
  height: 1px;
  top: 20px;
  left: 20px;
}

.circuit-line-2 {
  width: 1px;
  height: 30px;
  top: 20px;
  left: 20px;
}

.circuit-line-3 {
  width: 40px;
  height: 1px;
  bottom: 25px;
  right: 30px;
}

.circuit-line-4 {
  width: 1px;
  height: 25px;
  bottom: 25px;
  right: 30px;
}

/* Neon Dots with Glow Effect */
.circuit-dot {
  position: absolute;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background: #00ff9c;
  box-shadow: 0 0 6px #00ff9c, 0 0 12px #00ffcc;
  animation: pulse-dot 3s infinite ease-in-out;
  opacity: 0.8;
}

.circuit-dot-1 {
  top: 20px;
  left: 20px;
}

.circuit-dot-2 {
  top: 50px;
  left: 20px;
}

.circuit-dot-3 {
  bottom: 25px;
  right: 30px;
}

.circuit-dot-4 {
  bottom: 50px;
  right: 30px;
}

/* Neon Animations */
@keyframes flicker {
  0%, 100% {
    opacity: 0.2;
  }
  50% {
    opacity: 0.4;
    box-shadow: 0 0 8px #00ffcc, 0 0 16px #00ffcc;
  }
}

@keyframes pulse-dot {
  0%, 100% {
    transform: scale(1);
    opacity: 0.8;
  }
  50% {
    transform: scale(1.2);
    opacity: 1;
    box-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;
  }
}

/* Override padding in Tailwind with matrix-style consistency */
.p-4,
.p-6 {
  padding: 1rem !important;
}

/* Validation status styles */
.validation-status {
    display: none;
    margin-top: 1rem;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.9rem;
    color: var(--color-text-dim);
}

.validation-progress {
    margin-top: 0.5rem;
    height: 6px;
    width: 100%;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
    overflow: hidden;
}

.validation-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
    transition: width 0.3s ease;
}

.validation-stats {
    display: flex;
    justify-content: space-between;
    margin-top: 0.5rem;
    font-size: 0.8rem;
}

.validation-check {
    margin-right: 0.5rem;
    display: inline-block;
    width: 16px;
    height: 16px;
}

.form-group.validation-group {
    display: flex;
    align-items: center;
    margin-bottom: 1rem;
}

.form-check {
    display: flex;
    align-items: center;
    cursor: pointer;
}

.form-check-input {
    margin-right: 0.5rem;
    cursor: pointer;
    width: 16px;
    height: 16px;
    accent-color: var(--color-primary);
}

.form-check-label {
    font-size: 0.9rem;
    cursor: pointer;
}

.select-info {
    font-size: 0.75rem;
    color: var(--color-text-dim);
    margin-top: 0.3rem;
    font-style: italic;
}

/* Download Button Styles */
.download-btn {
    margin-top: 10px;
    padding: 10px 16px;
    font-family: 'Orbitron', sans-serif;
    font-weight: 600;
    border-radius: 6px;
    background: rgba(0, 255, 0, 0.15); /* Hijau neon yang lebih lembut */
    border: 1px solid rgba(0, 255, 0, 0.5); /* Border hijau neon yang lebih lembut */
    color: #00ff00; /* Hijau neon untuk teks */
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3); /* Cahaya hijau lebih subtle */
}

.download-btn:hover {
    background: rgba(0, 255, 0, 0.3); /* Hover hijau neon yang lebih terang */
    border-color: rgba(0, 255, 0, 0.7); /* Hover border lebih cerah */
    box-shadow: 0 6px 28px rgba(0, 255, 0, 0.35); /* Cahaya hijau terang saat hover */
    transform: translateY(-2px);
}

.download-icon {
    width: 18px;
    height: 18px;
    filter: invert(1); /* Membuat ikon terlihat lebih terang dengan latar belakang hijau */
}

/* Copy Button Styles */
.copy-btn {
    margin-top: 10px;
    padding: 10px 16px;
    font-family: 'Orbitron', sans-serif;
    font-weight: 600;
    border-radius: 6px;
    background: rgba(0, 255, 0, 0.15); /* Hijau neon lembut */
    border: 1px solid rgba(0, 255, 0, 0.5); /* Border hijau neon lebih halus */
    color: #00ff00; /* Teks hijau neon */
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3); /* Cahaya hijau neon */
}

.copy-btn:hover {
    background: rgba(0, 255, 0, 0.3); /* Hover lebih terang */
    border-color: rgba(0, 255, 0, 0.7); /* Border lebih cerah saat hover */
    box-shadow: 0 6px 28px rgba(0, 255, 0, 0.35); /* Cahaya hijau terang saat hover */
    transform: translateY(-2px);
}

.copy-icon {
    width: 18px;
    height: 18px;
    filter: invert(1); /* Membuat ikon lebih terang dengan latar belakang hijau */
}

.action-buttons {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-top: 12px;
    flex-wrap: wrap;
}

.copy-btn, .download-btn {
    flex: 1;
    justify-content: center;
    text-align: center;
}

/* QR Code Button Styles */
.qrcode-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin: 20px auto;
    padding: 10px 16px;
    font-family: 'Orbitron', sans-serif;
    font-weight: 600;
    border-radius: 6px;
    background: rgba(0, 255, 0, 0.15); /* Hijau neon lembut */
    border: 1px solid rgba(0, 255, 0, 0.5); /* Border hijau neon lebih halus */
    color: #00ff00; /* Teks hijau neon */
    gap: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3); /* Cahaya hijau neon */
    display: flex;
}

.qrcode-btn:hover {
    background: rgba(0, 255, 0, 0.25); /* Hover lebih terang */
    border-color: rgba(0, 255, 0, 0.7); /* Border lebih cerah saat hover */
    box-shadow: 0 6px 28px rgba(0, 255, 0, 0.35); /* Cahaya hijau terang saat hover */
    transform: translateY(-2px);
}

.qrcode-icon {
    width: 18px;
    height: 18px;
    transition: all 0.3s ease;
    filter: invert(1); /* Mengubah warna ikon menjadi terang dengan latar belakang hijau */
}

.qrcode-icon:hover {
    transform: scale(1.2);
}

.center {
    display: flex;
    justify-content: center;
}

  footer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(0, 0, 0, 0.85); /* Latar gelap seperti terminal */
    color: #00ff00; /* Teks hijau neon ala hacker */
    font-size: 13px;
    font-family: 'Share Tech Mono', monospace; /* Font terminal */
    font-weight: 500;
    text-align: center;
    padding: 10px 0;
    border-top: 1px solid rgba(0, 255, 0, 0.2); /* Garis atas neon subtle */
    box-shadow: 0 -2px 10px rgba(0, 255, 0, 0.1); /* Efek glow atas */
    z-index: 1000;
}

.spacer {
    margin-top: 50px;
  }
  
  .copy-btn,
.list-btn,
.download-btn,
.qrcode-btn {
  font-size: 0.6rem;
  padding: 9px 10px;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto;
}

.qrcode-btn i,
.copy-btn i,
.list-btn i,
.download-btn i {
  margin-right: 5px;
}

.nav-buttons {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  padding: 15px 0;
}

.nav-button {
  background: rgba(0, 255, 0, 0.15);
  border: 1px solid rgba(0, 255, 0, 0.3);
  color: rgba(0, 255, 0, 0.85);
  font-family: 'Share Tech Mono', monospace;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 0.85rem;
  transition: all 0.3s ease;
  text-decoration: none;
  display: flex;
  align-items: center;
  gap: 5px;
  box-shadow: 0 0 6px rgba(0, 255, 0, 0.4);
}

.nav-button:hover {
  background: rgba(0, 255, 0, 0.25);
  color: #ffffff;
  transform: translateY(-2px);
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.6);
  border-color: rgba(0, 255, 0, 0.5);
}

.nav-button.active {
  background: linear-gradient(90deg, #00ff00, #00cc33, #009900);
  color: white;
  border: none;
  box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
}

</style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="tech-detail tech-detail-1"></div>
            <div class="tech-detail tech-detail-2"></div>
            <div class="tech-detail tech-detail-3"></div>
            
            <div class="title-container">
                <h1 class="title">BENXX - PROJECT</h1>
                <p class="subtitle">Advanced Subscription Link Generator</p>
            </div>

            <div class="nav-buttons">
                <a href="/" class="nav-button">
                    <i class="fas fa-home"></i> Home
                </a>
                <a href="sub" class="nav-button active">
                    <i class="fas fa-rss"></i> Subscription
                </a>
                <a href="link" class="nav-button">
                    <i class="fas fa-link"></i> Link Generator
                </a>
                <a href="converter" class="nav-button">
                    <i class="fas fa-exchange-alt"></i> Converter
                </a>
                <a href="checker" class="nav-button">
                    <i class="fas fa-cloud"></i> IP Checker
                </a>
                
            <form id="subLinkForm">
                <div class="form-group">
                    <label for="configType" style="font-weight: bold;">PROTOCOL TYPE</label>
                    <select id="configType" class="form-control" required>
                        <option value="vless">VLESS</option>
                        <option value="vmess">VMESS</option>
                        <option value="trojan">TROJAN</option>
                        <option value="shadowsocks">SHADOWSOCKS</option>
                        <option value="mix">MIX (ALL PROTOCOLS)</option>
                    </select>
                </div>

                <div class="form-group">
                <label for="formatType">FORMAT TYPE</label>
                <select id="formatType" class="form-control" required>
                    <option value="v2ray">V2RAY</option>
                    <option value="clash">CLASH</option>
                    <option value="singbox">SINGBOX</option>
                    <option value="singboxxl">SINGBOX V1.10.3 (cocok buat paket xl)</option>
                    <option value="nekobox">NEKOBOX</option>
                    <option value="husi">HUSI</option>
                </select>
            </div>
            
                <label for="uuid" style="font-weight: bold;">UUID</label>
                <input type="text" id="uuid" class="form-control" value="f282b878-8711-45a1-8c69-5564172123c1" required>
                <button type="button" id="generateUuid" class="uuid-generate" style="display: none;">GENERATE</button>

                <div class="form-group">
                    <label for="bugType" style="font-weight: bold;">BUG TYPE</label>
                    <select id="bugType" class="form-control" required>
                        <option value="default">DEFAULT</option>
                        <option value="non-wildcard">NON-WILDCARD</option>
                        <option value="wildcard">WILDCARD</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="mainDomain" style="font-weight: bold;">MAIN DOMAIN <span class="info-badge">SELECT</span></label>
                    <select id="mainDomain" class="form-control" required></select>
                </div>
                
                <div id="customBugContainer" class="form-group custom-bug-container">
                    <label for="customBug" style="font-weight: bold;">CUSTOM BUG</label>
                    <input type="text" id="customBug" class="form-control" placeholder="e.g., google.com, youtube.com, instagram.com">
                    <div class="select-info">Separate multiple domains with commas</div>
                </div>
                
                <div class="form-group">
                    <label for="tls" style="font-weight: bold;">TLS ENCRYPTION</label>
                    <select id="tls" class="form-control">
                        <option value="true">ENABLED</option>
                        <option value="false">DISABLED</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="country" style="font-weight: bold;">REGION FILTER</label>
                        <select id="country" class="form-control">
                            <option value="">Loading regions...</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="limit" style="font-weight: bold;">QUANTITY</label>
                        <input type="number" id="limit" class="form-control" min="1" max="100" value="5" placeholder="Max 20" required>
                    </div>
                </div>
                
                <div class="form-group validation-group">
                    <label class="form-check">
                        <input type="checkbox" id="validateProxies" class="form-check-input" checked>
                        <span class="form-check-label" style="font-weight: bold;">Validate proxies before generating</span>
                    </label>
                </div>
                
                <button type="submit" class="btn" style="font-weight: bold;">Generate Configuration</button>
            </form>
            
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <div class="loading-text typing" style="font-weight: bold;">Fetching proxy data and generating configs...</div>
            </div>
            
            <div id="validation-status" class="validation-status">
                <div style="font-weight: bold;">Validating proxies... <span id="validation-count">0/0</span></div>
                <div class="validation-progress">
                    <div id="validation-bar" class="validation-bar"></div>
                </div>
                <div class="validation-stats">
                    <div style="font-weight: bold;">Valid: <span id="valid-count">0</span></div>
                    <div>Invalid: <span id="invalid-count">0</span></div>
                </div>
            </div>
            
            <div id="error-message" class="error-message"></div>
            
            <div id="result" class="result">
                <div class="result-header">
                    <div class="result-title" style="font-weight: bold;">CONFIGURATION GENERATED</div>
                </div>
                <div class="output-container">
                    <textarea id="output" class="output" readonly></textarea>
                </div>

                <div class="action-buttons">
                    <button id="copyLink" class="copy-btn">
                        <svg class="copy-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                        COPY
                    </button>

<button id="downloadConfig" class="download-btn">
    <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="7 10 12 15 17 10"/>
        <line x1="12" y1="15" x2="12" y2="3"/>
    </svg>
    DOWNLOAD
</button>
<button id="generateQR" class="qrcode-btn">
    <i class="bi bi-qr-code"></i>
    QR CODE (v2rayNG)
  </button>
</div>
</div>
  </div>
<div class="spacer"></div>
<footer>
  <div class="circuit-line circuit-line-1"></div>
  <div class="circuit-line circuit-line-2"></div>
  <div class="circuit-line circuit-line-3"></div>
  <div class="circuit-line circuit-line-4"></div>
  <div class="circuit-dot circuit-dot-1"></div>
  <div class="circuit-dot circuit-dot-2"></div>
  <div class="circuit-dot circuit-dot-3"></div>
  <div class="circuit-dot circuit-dot-4"></div>

  <div class="footer-powered" style="font-weight: bold;">POWERED BY SECURE TECHNOLOGY</div>
  <div class="footer-logo" style="font-weight: bold;">
    <a href="https://t.me/Bleszh" target="_blank" style="color: inherit; text-decoration: none;">
      BENXX-PROJECT
    </a>
  </div>
</footer>

<script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.min.js"></script>
<script>
document.getElementById('downloadConfig').addEventListener('click', function () {
    const configContent = document.getElementById('output').value;
    const format = document.getElementById('formatType').value;

    let extension = '';
    let prefix = '';
    let mimeType = '';
    
    switch (format) {
        case 'clash':
            extension = 'yaml';
            prefix = 'clash';
            mimeType = 'application/x-yaml';
            break;
        case 'singbox':
            extension = 'bpf';
            prefix = 'singbox';
            mimeType = 'application/octet-stream';
            break;
        case 'nekobox':
            extension = 'json';
            prefix = 'nekobox';
            mimeType = 'application/json';
            break;
        case 'v2ray':
            extension = 'txt';
            prefix = 'v2ray';
            mimeType = 'text/plain';
            break;
        default:
            alert('Format tidak dikenali!');
            return;
    }

    const randomNum = Math.floor(1000 + Math.random() * 9000); // 4 digit random
    const filename = `${prefix}-${randomNum}.${extension}`;

    const blob = new Blob([configContent], { type: mimeType });
    const downloadLink = document.createElement('a');
    downloadLink.href = URL.createObjectURL(blob);
    downloadLink.download = filename;
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
});
</script>
<script>
    document.getElementById('generateQR').addEventListener('click', function () {
        const input = document.getElementById('output').value.trim();
        const urls = input.split('\n').filter(url =>
            url.startsWith("vmess://") ||
            url.startsWith("vless://") ||
            url.startsWith("trojan://") ||
            url.startsWith("ss://") ||
            url.startsWith("v2ray://") ||
            url.startsWith("v2rayng://")
        );

        if (urls.length === 0) {
            alert("No valid config URLs found.");
            return;
        }

        document.querySelectorAll('.qr-modal').forEach(modal => modal.remove());

        const maxLength = 2950;
        let chunks = [];
        let tempChunk = "";

        for (let i = 0; i < urls.length; i++) {
            if ((tempChunk + urls[i] + "\n").length > maxLength) {
                chunks.push(tempChunk.trim());
                tempChunk = urls[i] + "\n";
            } else {
                tempChunk += urls[i] + "\n";
            }
        }
        if (tempChunk) chunks.push(tempChunk.trim());

        // Generate QR Code as Canvas
        function generateQRCodeCanvas(text) {
            const qr = qrcode(0, 'L');
            qr.addData(text);
            qr.make();
            const canvas = document.createElement('canvas');
            const cellSize = 3;
            const margin = 4;
            const size = qr.getModuleCount() * cellSize + margin * 2;
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');

            // background putih
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, size, size);

            // QR hitam-putih
            for (let row = 0; row < qr.getModuleCount(); row++) {
                for (let col = 0; col < qr.getModuleCount(); col++) {
                    ctx.fillStyle = qr.isDark(row, col) ? '#000000' : '#ffffff';
                    ctx.fillRect(margin + col * cellSize, margin + row * cellSize, cellSize, cellSize);
                }
            }

            return canvas;
        }

        if (chunks.length === 1) {
            // Single QR Modal
            const modal = document.createElement('div');
            modal.className = 'qr-modal modal-dialog-centered';
            modal.style = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.15);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
                border-radius: 20px;
                padding: 17px;
                z-index: 9999;
                text-align: center;
                border: 1px solid rgba(255, 255, 255, 0.3);
            `;

            const qrCanvas = generateQRCodeCanvas(chunks[0]);
            qrCanvas.style.width = '288px';
            qrCanvas.style.height = '288px';

            const downloadBtn = document.createElement('button');
            downloadBtn.classList.add('btn', 'btn-success', 'mt-2');
            downloadBtn.innerText = 'Download QR';
            downloadBtn.onclick = () => {
                const link = document.createElement('a');
                link.download = 'qr_code.jpg';
                link.href = qrCanvas.toDataURL('image/jpeg');
                link.click();
            };

            const closeBtn = document.createElement('button');
            closeBtn.classList.add('btn', 'btn-danger');
            closeBtn.style.marginTop = '10px'; // Bisa diubah sesuai kebutuhan
            closeBtn.innerText = 'Close';
            closeBtn.onclick = () => modal.remove();

            modal.appendChild(qrCanvas);
            modal.appendChild(downloadBtn);
            modal.appendChild(closeBtn);
            document.body.appendChild(modal);
        } else {
            // Multiple QR Modal
            let currentIndex = 0;
            const modal = document.createElement('div');
            modal.className = 'qr-modal modal-dialog-centered';
            modal.style = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.15);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
                border-radius: 20px;
                padding: 20px;
                z-index: 9999;
                text-align: center;
                border: 1px solid rgba(255, 255, 255, 0.3);
            `;

            const label = document.createElement('div');
            label.style.marginBottom = "10px";
            label.style.fontWeight = "bold";

            const qrContainer = document.createElement('div');

            const btnPrev = document.createElement('button');
btnPrev.classList.add('btn', 'btn-secondary');
btnPrev.innerText = 'Prev';
btnPrev.style.marginRight = '10px'; 

const btnNext = document.createElement('button');
btnNext.classList.add('btn', 'btn-secondary');
btnNext.innerText = 'Next';

const navContainer = document.createElement('div');
navContainer.style.display = 'flex';
navContainer.style.justifyContent = 'space-between';
navContainer.style.marginTop = '10px';
navContainer.appendChild(btnPrev);
navContainer.appendChild(btnNext);

const closeBtn = document.createElement('button');
closeBtn.classList.add('btn', 'btn-danger', 'mt-2');
closeBtn.innerText = 'Close';
closeBtn.style.display = 'block';
closeBtn.style.margin = '10px auto 0';

            modal.appendChild(label);
            modal.appendChild(qrContainer);
            modal.appendChild(navContainer);
            modal.appendChild(closeBtn);
            document.body.appendChild(modal);

            // Update QR and download for each chunk
            function updateQR(index) {
                const qrCanvas = generateQRCodeCanvas(chunks[index]);
                qrCanvas.style.width = '288px'; 
                qrCanvas.style.height = '288px';

                // Update QR image in modal
                qrContainer.innerHTML = '';
                qrContainer.appendChild(qrCanvas);

                // Update label for QR navigation
                label.innerHTML = `
                    <span style="color: blue;">QR</span>
                    <span style="color: blue;">${index + 1}</span>
                    <span style="color: green;">dari</span>
                    <span style="color: blue;">${chunks.length}</span>
                `;

                const downloadBtn = document.createElement('button');
                downloadBtn.classList.add('btn', 'btn-success', 'mt-2');
                downloadBtn.innerText = 'Download QR';
                downloadBtn.onclick = () => {
                    const link = document.createElement('a');
                    link.download = `qr_code_${index + 1}.jpg`;
                    link.href = qrCanvas.toDataURL('image/jpeg');
                    link.click();
                };
                qrContainer.appendChild(downloadBtn);
            }

            btnPrev.onclick = () => {
                if (currentIndex > 0) {
                    currentIndex--;
                    updateQR(currentIndex);
                }
            };

            btnNext.onclick = () => {
                if (currentIndex < chunks.length - 1) {
                    currentIndex++;
                    updateQR(currentIndex);
                }
            };

            closeBtn.onclick = () => modal.remove();

            // Initial QR update
            updateQR(currentIndex);
        }
    });
</script>
<script>
    // Constants
    const DEFAULT_PROXY_BANK_URL = 'https://raw.githubusercontent.com/jaka2m/botak/refs/heads/main/cek/proxyList.txt';
    const PROXY_CHECK_API_URL = 'https://cors.checker-ip.web.id/?url=https://api.checker-ip.web.id/check';
    const PATH_PREFIX = 'Geo-Project'; // Hardcoded path prefix
    const MainDomains = [
        'benxx.dpdns.org',
        'kosong'
    ];

    const CustomBugs = [];
    
    // Safe base64 encoding function
    function safeBase64Encode(str) {
        try {
            // Make sure we're working with a string
            const stringToEncode = typeof str === 'object' ? JSON.stringify(str) : String(str);
            return window.btoa(stringToEncode);
        } catch (e) {
            console.error("Base64 encoding error:", e);
            return "";
        }
    }
    
    // Check if proxy is valid via API
async function checkProxyValidity(ip, port) {
    try {
        const response = await fetch(`${PROXY_CHECK_API_URL}?ip=${ip}:${port}`);
        
        if (!response.ok) {
            console.error(`API error: ${response.status}`);
            return false;
        }
        
        const data = await response.json();
        return data.status && data.status.toUpperCase() === "ACTIVE";
    } catch (error) {
        console.error("Error checking proxy:", error);
        return false;
    }
}

    // Create VMess config object
    function createVMessConfig(uuid, domain, host, sni, proxyHost, proxyPort, countryCode, isp, tls) {
    return {
        v: "2",
        ps: `${countryCode} - ${isp} [ VMESS - ${tls ? 'TLS' : 'NTLS'} ]`,
        add: domain,
        port: tls ? 443 : 80,
        id: uuid,
        aid: "0",
        net: "ws",
        type: "none",
        scy: "zero",
        host: host,
        path: `/${PATH_PREFIX}/${proxyHost}-${proxyPort}`,
        tls: tls ? "tls" : "none",
        sni: sni,
        fp: "randomized"
    };
}
    
    // Format label with protocol and TLS info
    function formatLabel(countryCode, isp, protocol, tls) {
        return `${countryCode} - ${isp} [ ${protocol.toUpperCase()} - ${tls ? 'TLS' : 'NTLS'} ]`;
    }

    // Function to get country name from country code
    function getCountryName(countryCode) {
        return countryCode;
    }

    // Function to fetch and populate regions from GitHub
    async function populateRegionsFromGitHub() {
        try {
            const response = await fetch(DEFAULT_PROXY_BANK_URL);
            if (!response.ok) {
                throw new Error(`Failed to fetch proxy data: ${response.status}`);
            }
            
            const proxyList = (await response.text()).split('\n').filter(Boolean);
            
            // Extract unique country codes
            const uniqueCountryCodes = new Set();
            
            proxyList.forEach(line => {
                const parts = line.split(',');
                if (parts.length >= 3) {
                    const countryCode = parts[2];
                    if (countryCode) {
                        uniqueCountryCodes.add(countryCode);
                    }
                }
            });
            
            // Sort country codes alphabetically
            const sortedCountryCodes = [...uniqueCountryCodes].sort();
            
            // Get the country select element
            const countrySelect = document.getElementById('country');
            
            // Keep the default options
            const defaultOptions = `
                <option value="">GLOBAL (ALL)</option>
                <option value="random">RANDOM</option>
            `;
            
            // Add the country codes from GitHub with their names
            let regionOptions = '';
            sortedCountryCodes.forEach(code => {
                regionOptions += `<option value="${code}">${code}</option>`;
            });
            
            // Update the select element
            countrySelect.innerHTML = defaultOptions + regionOptions;
            
            console.log(`Successfully loaded ${sortedCountryCodes.length} regions from GitHub`);
        } catch (error) {
            console.error("Error loading regions:", error);
        }
    }
    
// Generate Clash YAML for VLESS
function generateClashVLESS(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {
    return `- name: ${name}
  server: ${domain}
  port: ${tls ? 443 : 80}
  type: vless
  uuid: ${uuid}
  cipher: auto
  tls: ${tls}
  udp: false
  skip-cert-verify: true
  network: ws
  servername: ${sni}
  ws-opts:
    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}
    headers:
      Host: ${host}`;
}

// Generate Clash YAML for Trojan
function generateClashTrojan(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {
    return `- name: ${name}
  server: ${domain}
  port: ${tls ? 443 : 80}
  type: trojan
  password: ${uuid}
  udp: false
  skip-cert-verify: true
  network: ws
  sni: ${sni}
  ws-opts:
    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}
    headers:
      Host: ${host}`;
}

// Generate Clash YAML for Shadowsocks
function generateClashSS(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {
    return `- name: ${name}
  server: ${domain}
  port: ${tls ? 443 : 80}
  type: ss
  cipher: none
  password: ${uuid}
  plugin: v2ray-plugin
  client-fingerprint: chrome
  udp: false
  plugin-opts:
    mode: websocket
    host: ${host}
    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}
    tls: ${tls}
    mux: false
    skip-cert-verify: true
  headers:
    custom: value
    ip-version: dual
    v2ray-http-upgrade: false
    v2ray-http-upgrade-fast-open: false`;
}

// Generate Clash YAML for VMess
function generateClashVMess(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {
    return `- name: ${name}
  server: ${domain}
  port: ${tls ? 443 : 80}
  type: vmess
  uuid: ${uuid}
  alterId: 0
  cipher: zero
  tls: ${tls}
  skip-cert-verify: true
  servername: ${sni}
  network: ws
  ws-opts:
    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}
    headers:
      Host: ${host}
  udp: true`;
}

// Generate Singbox configuration
function generateSingboxConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {
    const ports = tls ? '443' : '80';
    const snio = tls ? `\n      "tls": {\n        "enabled": true,\n        "server_name": "${sni}",\n        "insecure": true\n      },` : '';
    
    let config = '';
    if (type === 'vless') {
        config = `    {
      "type": "vless",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "uuid": "${uuid}",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        },
        "early_data_header_name": "Sec-WebSocket-Protocol"
      },
      "packet_encoding": "xudp"
    }`;
    } else if (type === 'vmess') {
        config = `    {
      "type": "vmess",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "uuid": "${uuid}",
      "alter_id": 0,
      "security": "zero",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        },
        "early_data_header_name": "Sec-WebSocket-Protocol"
      },
      "packet_encoding": "xudp"
    }`;
    } else if (type === 'trojan') {
        config = `    {
      "type": "trojan",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "password": "${uuid}",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        },
        "early_data_header_name": "Sec-WebSocket-Protocol"
      }
    }`;
    } else if (type === 'ss') {
        config = `    {
      "type": "shadowsocks",
      "tag": "${name}",
      "server": "${domain}",
      "server_port": 443,
      "method": "none",
      "password": "${uuid}",
      "plugin": "v2ray-plugin",
      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"
    }`;
    }
    
    return config;
}

// Generate Singbox configuration
function generateSingboxxlConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {
    const ports = tls ? '443' : '80';
    const snio = tls ? `\n      "tls": {\n        "enabled": true,\n        "server_name": "${sni}",\n        "insecure": true\n      },` : '';
    
    let config = '';
    if (type === 'vless') {
        config = `    {
      "type": "vless",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "uuid": "${uuid}",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        }
      },
      "domain_strategy": "ipv4_only"
    }`;
    } else if (type === 'vmess') {
        config = `    {
      "type": "vmess",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "uuid": "${uuid}",
      "alter_id": 0,
      "security": "zero",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        }
      },
      "domain_strategy": "ipv4_only"
    }`;
    } else if (type === 'trojan') {
        config = `    {
      "type": "trojan",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "password": "${uuid}",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        }
      },
      "domain_strategy": "ipv4_only"
    }`;
    } else if (type === 'ss') {
        config = `    {
      "type": "shadowsocks",
      "tag": "${name}",
      "server": "${domain}",
      "server_port": 443,
      "method": "none",
      "password": "${uuid}",
      "plugin": "v2ray-plugin",
      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"
    }`;
    }
    
    return config;
}

// Generate Nekobox configuration
function generateNekoboxConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {
    const ports = tls ? '443' : '80';
    const snio = tls ? `\n      "tls": {\n        "disable_sni": false,\n        "enabled": true,\n        "insecure": true,\n        "server_name": "${sni}"\n      },` : '';
    
    let config = '';
    if (type === 'vless') {
        config = `    {
      "domain_strategy": "ipv4_only",
      "flow": "",
      "multiplex": {
        "enabled": false,
        "max_streams": 32,
        "protocol": "smux"
      },
      "packet_encoding": "xudp",
      "server": "${domain}",
      "server_port": ${ports},
      "tag": "${name}",${snio}
      "transport": {
        "early_data_header_name": "Sec-WebSocket-Protocol",
        "headers": {
          "Host": "${host}"
        },
        "max_early_data": 0,
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "type": "ws"
      },
      "type": "vless",
      "uuid": "${uuid}"
    }`;
    } else if (type === 'trojan') {
        config = `    {
      "domain_strategy": "ipv4_only",
      "multiplex": {
        "enabled": false,
        "max_streams": 32,
        "protocol": "smux"
      },
      "password": "${uuid}",
      "server": "${domain}",
      "server_port": ${ports},
      "tag": "${name}",${snio}
      "transport": {
        "early_data_header_name": "Sec-WebSocket-Protocol",
        "headers": {
          "Host": "${host}"
        },
        "max_early_data": 0,
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "type": "ws"
      },
      "type": "trojan"
    }`;
    } else if (type === 'vmess') {
        config = `    {
      "domain_strategy": "ipv4_only",
      "multiplex": {
        "enabled": false,
        "max_streams": 32,
        "protocol": "smux"
      },
      "packet_encoding": "xudp",
      "server": "${domain}",
      "server_port": ${ports},
      "tag": "${name}",${snio}
      "transport": {
        "early_data_header_name": "Sec-WebSocket-Protocol",
        "headers": {
          "Host": "${host}"
        },
        "max_early_data": 0,
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "type": "ws"
      },
      "type": "vmess",
      "uuid": "${uuid}",
      "alter_id": 0,
      "security": "zero"
    }`;
    } else if (type === 'ss') {
        config = `    {
      "type": "shadowsocks",
      "tag": "${name}",
      "server": "${domain}",
      "server_port": 443,
      "method": "none",
      "password": "${uuid}",
      "plugin": "v2ray-plugin",
      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"
    }`;
    }
    
    return config;
}
function generatehusiConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {
    const ports = tls ? '443' : '80';
    const snio = tls ? `\n      "tls": {\n        "enabled": true,\n        "server_name": "${sni}",\n        "insecure": true\n      },` : '';
    
    let config = '';
    if (type === 'vless') {
        config = `    {
      "type": "vless",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "uuid": "${uuid}",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        },
        "early_data_header_name": "Sec-WebSocket-Protocol"
      },
      "packet_encoding": "xudp"
    }`;
    } else if (type === 'vmess') {
        config = `    {
      "type": "vmess",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "uuid": "${uuid}",
      "alter_id": 0,
      "security": "zero",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        },
        "early_data_header_name": "Sec-WebSocket-Protocol"
      },
      "packet_encoding": "xudp"
    }`;
    } else if (type === 'trojan') {
        config = `    {
      "type": "trojan",
      "tag": "${name}",
      "domain_strategy": "ipv4_only",
      "server": "${domain}",
      "server_port": ${ports},
      "password": "${uuid}",${snio}
      "multiplex": {
        "protocol": "smux",
        "max_streams": 32
      },
      "transport": {
        "type": "ws",
        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",
        "headers": {
          "Host": "${host}"
        },
        "early_data_header_name": "Sec-WebSocket-Protocol"
      }
    }`;
    } else if (type === 'ss') {
        config = `    {
      "type": "shadowsocks",
      "tag": "${name}",
      "server": "${domain}",
      "server_port": 443,
      "method": "none",
      "password": "${uuid}",
      "plugin": "v2ray-plugin",
      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"
    }`;
    }
    
    return config;
}

// Main Function
const usedProxies = new Set();
async function generateV2raySub(type, uuid, bugType, mainDomain, customBugs, tls, validateProxies, formatType, country = null, limit = 9999) {
    try {
        const response = await fetch(`${DEFAULT_PROXY_BANK_URL}?_=${Date.now()}`);
        if (!response.ok) {
            throw new Error(`Failed to fetch proxy data: ${response.status}`);
        }

        const proxyList = (await response.text()).split('\n').filter(Boolean);

        let filteredProxies = proxyList;

        if (country) {
            filteredProxies = proxyList.filter(line => {
                const parts = line.split(',');
                return parts.length >= 3 && parts[2]?.toUpperCase() === country.toUpperCase();
            });
        }

        if (filteredProxies.length === 0) {
            throw new Error("No proxies found matching your region criteria");
        }

        filteredProxies = filteredProxies.sort(() => Math.random() - 0.5);

        // Apply limit after shuffle (limit default: 9999)
        let limitedProxies = filteredProxies.slice(0, parseInt(limit));

        const firstBug = customBugs && customBugs.length > 0 ? customBugs[0] : null;

        let domain, host, sni;
        
        switch (bugType) {
            case 'default':
                domain = mainDomain;
                host = mainDomain;
                sni = mainDomain;
                break;
            case 'non-wildcard':
                domain = firstBug || mainDomain;
                host = mainDomain;
                sni = mainDomain;
                break;
            case 'wildcard':
                domain = firstBug || mainDomain;
                host = `${firstBug}.${mainDomain}`;
                sni = `${firstBug}.${mainDomain}`;
                break;
        }

        const results = [];
        let validProxies = [];
        
        // Check proxy validity if enabled
        if (validateProxies) {
            // Show validation status UI
            document.getElementById('validation-status').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
            
            // Initialize validation UI
            const validationBar = document.getElementById('validation-bar');
            const validationCount = document.getElementById('validation-count');
            const validCountEl = document.getElementById('valid-count');
            const invalidCountEl = document.getElementById('invalid-count');
            
            validationBar.style.width = '0%';
            validationCount.textContent = `0/${limitedProxies.length}`;
            validCountEl.textContent = '0';
            invalidCountEl.textContent = '0';
            
            // Prepare validation tasks in batches to avoid overwhelming the browser
            const BATCH_SIZE = 10;
            let validCount = 0;
            let invalidCount = 0;
            let processedCount = 0;
            
            // Process proxies in batches
            for (let i = 0; i < limitedProxies.length; i += BATCH_SIZE) {
                const batch = limitedProxies.slice(i, i + BATCH_SIZE);
                const batchPromises = batch.map(async (line) => {
                    const parts = line.split(',');
                    if (parts.length < 3) {
                        return { line, isValid: false };
                    }
                    
                    const [proxyHost, proxyPort] = parts;
                    const isValid = await checkProxyValidity(proxyHost, proxyPort);
                    return { line, isValid };
                });
                
                const batchResults = await Promise.all(batchPromises);
                
                for (const result of batchResults) {
                    processedCount++;
                    
                    if (result.isValid) {
                        validCount++;
                        validProxies.push(result.line);
                    } else {
                        invalidCount++;
                    }
                    
                    if (processedCount % 3 === 0 || processedCount === limitedProxies.length) {
                        requestAnimationFrame(() => {
                            const percentage = (processedCount / limitedProxies.length) * 100;
                            validationBar.style.width = `${percentage}%`;
                            validationCount.textContent = `${processedCount}/${limitedProxies.length}`;
                            validCountEl.textContent = validCount;
                            invalidCountEl.textContent = invalidCount;
                        });
                    }
                }
            }
            
            if (validProxies.length === 0) {
                if (parseInt(limit) <= 5) {
                    console.log("No valid proxies found, using unvalidated ones");
                    validProxies = limitedProxies.slice(0, parseInt(limit));
                } else {
                    throw new Error("No valid proxies found");
                }
            }

            document.getElementById('validation-status').style.display = 'none';
            document.getElementById('loading').style.display = 'block';

            if (validProxies.length < parseInt(limit)) {
                const allValidatedHosts = new Set(limitedProxies.map(line => line.split(',')[0]));
                const newProxies = proxyList.filter(line => {
                    const host = line.split(',')[0];
                    return !allValidatedHosts.has(host) && !usedProxies.has(`${host}:${line.split(',')[1]}`);
                });
                
                const neededCount = parseInt(limit) - validProxies.length;
                const additionalProxies = newProxies.slice(0, neededCount);
                
                limitedProxies = [...validProxies, ...additionalProxies];
                limitedProxies = limitedProxies.slice(0, parseInt(limit));
            } else {
                limitedProxies = validProxies.slice(0, parseInt(limit));
            }
        }
        
        // Mark proxies as used before generating configs
        limitedProxies.forEach(line => {
            const [host, port] = line.split(',');
            usedProxies.add(`${host}:${port}`);
        });

        // Rest of your original config generation code remains the same...
        // For Clash format
        if (formatType === 'clash') {
            let allProxies = [];
            
            for (let i = 0; i < limitedProxies.length; i++) {
                const line = limitedProxies[i];
                const parts = line.split(',');
                if (parts.length < 3) continue;
                
                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;
                const isp = ispParts.join(' ') || 'Unknown';
                
                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];
                
                for (const bug of bugsToUse) {
                    let bugDomain, bugHost, bugSni;
                    
                    switch (bugType) {
                        case 'default':
                            bugDomain = mainDomain;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'non-wildcard':
                            bugDomain = bug;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'wildcard':
                            bugDomain = bug;
                            bugHost = `${bug}.${mainDomain}`;
                            bugSni = `${bug}.${mainDomain}`;
                            break;
                    }
                    
                    const bugLabel = bug !== mainDomain ? `[${bug}]` : '';
                    const name = `${countryCode} - ${isp} ${bugLabel} ${i+1}`;
                    
                    switch (type) {
                        case 'vless':
                            allProxies.push(generateClashVLESS(`${name}-[VLESS-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            break;
                        case 'vmess':
                            allProxies.push(generateClashVMess(`${name}-[VMESS-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            break;
                        case 'trojan':
                            allProxies.push(generateClashTrojan(`${name}-[TROJAN-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            break;
                        case 'shadowsocks':
                            allProxies.push(generateClashSS(`${name}-[SS-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            break;
                        case 'mix':
                            const mixIndex = i + 1;
                            allProxies.push(generateClashVLESS(`${countryCode} - ${isp} ${bugLabel}-[VLESS-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.1`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            allProxies.push(generateClashTrojan(`${countryCode} - ${isp} ${bugLabel}-[TROJAN-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.2`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            allProxies.push(generateClashSS(`${countryCode} - ${isp} ${bugLabel}-[SS-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.3`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            allProxies.push(generateClashVMess(`${countryCode} - ${isp} ${bugLabel}-[VMESS-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.4`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));
                            break;
                    }
                }
            }
            
            return `#Geo-Project\nproxies:\n${allProxies.join('\n')}`;
        }  
        // For Singbox format
        else if (formatType === 'singbox') {
            let allProxies = [];
            let proxyTags = [];
            
            for (let i = 0; i < limitedProxies.length; i++) {
                const line = limitedProxies[i];
                const parts = line.split(',');
                if (parts.length < 3) continue;
                
                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;
                const isp = ispParts.join(' ') || 'Unknown';
                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();
                
                // If we have multiple bugs, create configs for each bug
                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];
                
                for (const bug of bugsToUse) {
                    // Determine domain, host, and SNI for this specific bug
                    let bugDomain, bugHost, bugSni;
                    
                    switch (bugType) {
                        case 'default':
                            bugDomain = mainDomain;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'non-wildcard':
                            bugDomain = bug;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'wildcard':
                            bugDomain = bug;
                            bugHost = `${bug}.${mainDomain}`;
                            bugSni = `${bug}.${mainDomain}`;
                            break;
                    }
                    
                    const bugLabel = bug !== mainDomain ? `[${bug}]` : '';
                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;
                    
                    switch (type) {
                        case 'vmess':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            break;
                        case 'vless':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            break;
                        case 'trojan':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            break;
                        case 'shadowsocks':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                        case 'mix':
                            proxyTags.push(`        "${name} vmess",`);
                            proxyTags.push(`        "${name} vless",`);
                            proxyTags.push(`        "${name} trojan",`);
                            proxyTags.push(`        "${name} ss",`);
                            allProxies.push(generateSingboxConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            allProxies.push(generateSingboxConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            allProxies.push(generateSingboxConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            allProxies.push(generateSingboxConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                    }
                }
            }
            
            // Remove trailing comma from the last proxy
            if (allProxies.length > 0) {
                const lastProxy = allProxies[allProxies.length - 1];
                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');
            }
            
            // Create the full Singbox configuration
            return `#### BENXX PROJECT #### 

{
  "log": {
    "level": "info"
  },
  "dns": {
    "servers": [
      {
        "tag": "remote-dns",
        "address": "https://family.cloudflare-dns.com/dns-query",
        "address_resolver": "direct-dns",
        "strategy": "ipv4_only"
      },
      {
        "tag": "direct-dns",
        "address": "local",
        "strategy": "ipv4_only"
      },
      {
        "tag": "dns-final",
        "address": "local",
        "address_resolver": "dns-local",
        "strategy": "ipv4_only"
      },
      {
        "tag": "dns-local",
        "address": "local"
      },
      {
        "tag": "dns-block",
        "address": "rcode://success"
      }
    ],
    "rules": [
      {
        "domain": [
          "family.cloudflare-dns.com",
          "${domain}"
        ],
        "server": "direct-dns"
      }
    ],
    "final": "dns-final",
    "independent_cache": true
  },
  "inbounds": [
    {
      "type": "tun",
      "mtu": 1400,
      "inet4_address": "172.19.0.1/30",
      "inet6_address": "fdfe:dcba:9876::1/126",
      "auto_route": true,
      "strict_route": true,
      "endpoint_independent_nat": true,
      "stack": "mixed",
      "sniff": true
    }
  ],
  "outbounds": [
    {
      "tag": "Internet",
      "type": "selector",
      "outbounds": [
        "Best Latency",
${proxyTags.join('\n')}
        "direct"
      ]
    },
    {
      "type": "urltest",
      "tag": "Best Latency",
      "outbounds": [
${proxyTags.join('\n')}
        "direct"
      ],
      "url": "https://ping.wildcrd.us.kg",
      "interval": "30s"
    },
${allProxies.join(',\n')},
    {
      "type": "direct",
      "tag": "direct"
    },
    {
      "type": "direct",
      "tag": "bypass"
    },
    {
      "type": "block",
      "tag": "block"
    },
    {
      "type": "dns",
      "tag": "dns-out"
    }
  ],
  "route": {
    "rules": [
      {
        "port": 53,
        "outbound": "dns-out"
      },
      {
        "inbound": "dns-in",
        "outbound": "dns-out"
      },
      {
        "network": "udp",
        "port": 443,
        "outbound": "block"
      },
      {
        "source_ip_cidr": [
          "224.0.0.0/3",
          "ff00::/8"
        ],
        "ip_cidr": [
          "224.0.0.0/3",
          "ff00::/8"
        ],
        "outbound": "block"
      }
    ],
    "auto_detect_interface": true
  },
  "experimental": {
    "cache_file": {
      "enabled": false
    },
    "clash_api": {
      "external_controller": "127.0.0.1:9090",
      "external_ui": "ui",
      "external_ui_download_url": "https://github.com/MetaCubeX/metacubexd/archive/gh-pages.zip",
      "external_ui_download_detour": "Internet",
      "secret": "geo",
      "default_mode": "rule"
    }
  }
}`;
        }
                // For Singbox format
        else if (formatType === 'singboxxl') {
            let allProxies = [];
            let proxyTags = [];
            
            for (let i = 0; i < limitedProxies.length; i++) {
                const line = limitedProxies[i];
                const parts = line.split(',');
                if (parts.length < 3) continue;
                
                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;
                const isp = ispParts.join(' ') || 'Unknown';
                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();
                
                // If we have multiple bugs, create configs for each bug
                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];
                
                for (const bug of bugsToUse) {
                    // Determine domain, host, and SNI for this specific bug
                    let bugDomain, bugHost, bugSni;
                    
                    switch (bugType) {
                        case 'default':
                            bugDomain = mainDomain;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'non-wildcard':
                            bugDomain = bug;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'wildcard':
                            bugDomain = bug;
                            bugHost = `${bug}.${mainDomain}`;
                            bugSni = `${bug}.${mainDomain}`;
                            break;
                    }
                    
                    const bugLabel = bug !== mainDomain ? `[${bug}]` : '';
                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;
                    
                    switch (type) {
                        case 'vmess':
                            proxyTags.push(`        "${name}"`);
                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            break;
                        case 'vless':
                            proxyTags.push(`        "${name}"`);
                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            break;
                        case 'trojan':
                            proxyTags.push(`        "${name}"`);
                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            break;
                        case 'shadowsocks':
                            proxyTags.push(`        "${name}"`);
                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                        case 'mix':
                            proxyTags.push(`        "${name} vmess"`);
                            proxyTags.push(`        "${name} vless"`);
                            proxyTags.push(`        "${name} trojan"`);
                            proxyTags.push(`        "${name} ss"`);
                            allProxies.push(generateSingboxxlConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            allProxies.push(generateSingboxxlConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            allProxies.push(generateSingboxxlConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            allProxies.push(generateSingboxxlConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                    }
                }
            }
            
            // Remove trailing comma from the last proxy
            if (allProxies.length > 0) {
                const lastProxy = allProxies[allProxies.length - 1];
                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');
            }
            
            // Create the full Singbox configuration
            return `#### BENXX PROJECT #### 

{
  "log": {
    "level": "panic"
  },
  "dns": {
    "servers": [
      {
        "tag": "remote",
        "address": [
          "tls://223.5.5.5",
          "tls://223.6.6.6"
        ]
      },
      {
        "tag": "local",
        "address": [
          "112.215.203.246",
          "112.215.203.247",
          "112.215.203.248",
          "112.215.203.254",
          "112.215.198.248",
          "112.215.198.254"
        ],
        "detour": "direct"
      }
    ],
    "rules": [
      {
        "outbound": "any",
        "server": "local"
      }
    ],
    "strategy": "prefer_ipv4"
  },
  "inbounds": [
    {
      "type": "tun",
      "interface_name": "tun0",
      "mtu": 1400,
      "address": "172.19.0.1/30",
      "auto_route": true,
      "stack": "gvisor",
      "sniff": true
    },
    {
      "type": "mixed",
      "listen": "0.0.0.0",
      "listen_port": 2080,
      "sniff": true
    }
  ],
  "outbounds": [
    {
      "type": "selector",
      "tag": "GLOBAL",
      "outbounds": [
${proxyTags.join(',' + '\n')}
      ]
    },
    {
      "type": "urltest",
      "tag": "AUTO",
      "outbounds": [
${proxyTags.join(',' + '\n')}
      ],
         "url": "https://www.google.com",
         "interval": "10s",
         "tolerance": 50
    },
${allProxies.join(',\n')},
    {
      "type": "direct",
      "tag": "direct"
    },
    {
      "type": "block",
      "tag": "block"
    },
    {
      "type": "dns",
      "tag": "dns-out"
    }
  ],
  "route": {
    "rules": [
      {
        "protocol": "dns",
        "outbound": "dns-out"
      },
      {
        "network": "udp",
        "port": [443, 3478, 500, 4500],
        "outbound": "block"
      }
    ],
    "auto_detect_interface": true
  },
  "experimental": {
    "cache_file": {
      "enabled": true,
       "path": "cache.db"
    },
    "clash_api": {
      "external_controller": "0.0.0.0:9090",
      "external_ui": "dashboard"
    }
  }
}`;
        }
        // For Nekobox format
        else if (formatType === 'nekobox') {
            let allProxies = [];
            let proxyTags = [];
            
            for (let i = 0; i < limitedProxies.length; i++) {
                const line = limitedProxies[i];
                const parts = line.split(',');
                if (parts.length < 3) continue;
                
                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;
                const isp = ispParts.join(' ') || 'Unknown';
                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();
                
                // If we have multiple bugs, create configs for each bug
                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];
                
                for (const bug of bugsToUse) {
                    // Determine domain, host, and SNI for this specific bug
                    let bugDomain, bugHost, bugSni;
                    
                    switch (bugType) {
                        case 'default':
                            bugDomain = mainDomain;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'non-wildcard':
                            bugDomain = bug;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'wildcard':
                            bugDomain = bug;
                            bugHost = `${bug}.${mainDomain}`;
                            bugSni = `${bug}.${mainDomain}`;
                            break;
                    }
                    
                    const bugLabel = bug !== mainDomain ? `[${bug}]` : '';
                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;
                    
                    switch (type) {
                        case 'vless':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            break;
                        case 'vmess':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            break;
                        case 'trojan':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            break;
                        case 'shadowsocks':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                        case 'mix':
                            proxyTags.push(`        "${name} vless",`);
                            proxyTags.push(`        "${name} vmess",`);
                            proxyTags.push(`        "${name} trojan",`);
                            proxyTags.push(`        "${name} ss",`);
                            allProxies.push(generateNekoboxConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            allProxies.push(generateNekoboxConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            allProxies.push(generateNekoboxConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            allProxies.push(generateNekoboxConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                    }
                }
            }
            
            // Remove trailing comma from the last proxy
            if (allProxies.length > 0) {
                const lastProxy = allProxies[allProxies.length - 1];
                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');
            }
            
            // Create the full Nekobox configuration
            return `#### BENXX PROJECT #### 

{
  "dns": {
    "final": "dns-final",
    "independent_cache": true,
    "rules": [
      {
        "disable_cache": false,
        "domain": [
          "family.cloudflare-dns.com",
          "${domain}"
        ],
        "server": "direct-dns"
      }
    ],
    "servers": [
      {
        "address": "https://family.cloudflare-dns.com/dns-query",
        "address_resolver": "direct-dns",
        "strategy": "ipv4_only",
        "tag": "remote-dns"
      },
      {
        "address": "local",
        "strategy": "ipv4_only",
        "tag": "direct-dns"
      },
      {
        "address": "local",
        "address_resolver": "dns-local",
        "strategy": "ipv4_only",
        "tag": "dns-final"
      },
      {
        "address": "local",
        "tag": "dns-local"
      },
      {
        "address": "rcode://success",
        "tag": "dns-block"
      }
    ]
  },
  "experimental": {
    "cache_file": {
      "enabled": true,
      "path": "../cache/clash.db",
      "store_fakeip": true
    },
    "clash_api": {
      "external_controller": "127.0.0.1:9090",
      "external_ui": "../files/yacd"
    }
  },
  "inbounds": [
    {
      "listen": "0.0.0.0",
      "listen_port": 6450,
      "override_address": "8.8.8.8",
      "override_port": 53,
      "tag": "dns-in",
      "type": "direct"
    },
    {
      "domain_strategy": "",
      "endpoint_independent_nat": true,
      "inet4_address": [
        "172.19.0.1/28"
      ],
      "mtu": 9000,
      "sniff": true,
      "sniff_override_destination": true,
      "stack": "system",
      "tag": "tun-in",
      "type": "tun"
    },
    {
      "domain_strategy": "",
      "listen": "0.0.0.0",
      "listen_port": 2080,
      "sniff": true,
      "sniff_override_destination": true,
      "tag": "mixed-in",
      "type": "mixed"
    }
  ],
  "log": {
    "level": "info"
  },
  "outbounds": [
    {
      "outbounds": [
        "Best Latency",
${proxyTags.join('\n')}
        "direct"
      ],
      "tag": "Internet",
      "type": "selector"
    },
    {
      "interval": "1m0s",
      "outbounds": [
${proxyTags.join('\n')}
        "direct"
      ],
      "tag": "Best Latency",
      "type": "urltest",
      "url": "https://detectportal.firefox.com/success.txt"
    },
${allProxies.join(',\n')},
    {
      "tag": "direct",
      "type": "direct"
    },
    {
      "tag": "bypass",
      "type": "direct"
    },
    {
      "tag": "block",
      "type": "block"
    },
    {
      "tag": "dns-out",
      "type": "dns"
    }
  ],
  "route": {
    "auto_detect_interface": true,
    "rules": [
      {
        "outbound": "dns-out",
        "port": [
          53
        ]
      },
      {
        "inbound": [
          "dns-in"
        ],
        "outbound": "dns-out"
      },
      {
        "network": [
          "udp"
        ],
        "outbound": "block",
        "port": [
          443
        ],
        "port_range": []
      },
      {
        "ip_cidr": [
          "224.0.0.0/3",
          "ff00::/8"
        ],
        "outbound": "block",
        "source_ip_cidr": [
          "224.0.0.0/3",
          "ff00::/8"
        ]
      }
    ]
  }
}`;
}
else if (formatType === 'husi') {
            let allProxies = [];
            let proxyTags = [];
            
            for (let i = 0; i < limitedProxies.length; i++) {
                const line = limitedProxies[i];
                const parts = line.split(',');
                if (parts.length < 3) continue;
                
                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;
                const isp = ispParts.join(' ') || 'Unknown';
                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();
                
                // If we have multiple bugs, create configs for each bug
                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];
                
                for (const bug of bugsToUse) {
                    // Determine domain, host, and SNI for this specific bug
                    let bugDomain, bugHost, bugSni;
                    
                    switch (bugType) {
                        case 'default':
                            bugDomain = mainDomain;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'non-wildcard':
                            bugDomain = bug;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'wildcard':
                            bugDomain = bug;
                            bugHost = `${bug}.${mainDomain}`;
                            bugSni = `${bug}.${mainDomain}`;
                            break;
                    }
                    
                    const bugLabel = bug !== mainDomain ? `[${bug}]` : '';
                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;
                    
                    switch (type) {
                        case 'vmess':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            break;
                        case 'vless':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            break;
                        case 'trojan':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            break;
                        case 'shadowsocks':
                            proxyTags.push(`        "${name}",`);
                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                        case 'mix':
                            proxyTags.push(`        "${name} vmess",`);
                            proxyTags.push(`        "${name} vless",`);
                            proxyTags.push(`        "${name} trojan",`);
                            proxyTags.push(`        "${name} ss",`);
                            allProxies.push(generatehusiConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));
                            allProxies.push(generatehusiConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));
                            allProxies.push(generatehusiConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));
                            allProxies.push(generatehusiConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));
                            break;
                    }
                }
            }
            
            // Remove trailing comma from the last proxy
            if (allProxies.length > 0) {
                const lastProxy = allProxies[allProxies.length - 1];
                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');
            }
            
            // Create the full husi configuration
            return `#### BENXX PROJECT #### 

{
  "dns": {
    "final": "dns-final",
    "independent_cache": true,
    "rules": [
      {
        "disable_cache": false,
        "domain": [
          "family.cloudflare-dns.com",
          "${domain}"
        ],
        "server": "direct-dns"
      }
    ],
    "servers": [
      {
        "address": "https://family.cloudflare-dns.com/dns-query",
        "address_resolver": "direct-dns",
        "strategy": "ipv4_only",
        "tag": "remote-dns"
      },
      {
        "address": "local",
        "strategy": "ipv4_only",
        "tag": "direct-dns"
      },
      {
        "address": "local",
        "address_resolver": "dns-local",
        "strategy": "ipv4_only",
        "tag": "dns-final"
      },
      {
        "address": "local",
        "tag": "dns-local"
      },
      {
        "address": "rcode://success",
        "tag": "dns-block"
      }
    ]
  },
  "experimental": {
    "cache_file": {
      "enabled": true,
      "path": "../cache/cache.db",
      "store_fakeip": true
    },
    "clash_api": {
      "external_controller": "127.0.0.1:9090"
    },
    "v2ray_api": {
      "listen": "127.0.0.1:0",
      "stats": {
        "enabled": true,
        "outbounds": [
          "proxy",
          "direct"
        ]
      }
    }
  },
  "inbounds": [
    {
      "listen": "0.0.0.0",
      "listen_port": 6450,
      "override_address": "8.8.8.8",
      "override_port": 53,
      "tag": "dns-in",
      "type": "direct"
    },
    {
      "domain_strategy": "",
      "endpoint_independent_nat": true,
      "inet4_address": [
        "172.19.0.1/28"
      ],
      "mtu": 9000,
      "sniff": true,
      "sniff_override_destination": true,
      "stack": "system",
      "tag": "tun-in",
      "type": "tun"
    },
    {
      "domain_strategy": "",
      "listen": "0.0.0.0",
      "listen_port": 2080,
      "sniff": true,
      "sniff_override_destination": true,
      "tag": "mixed-in",
      "type": "mixed"
    }
  ],
  "log": {
    "level": "info"
  },
  "outbounds": [
    {
      "outbounds": [
        "Best Latency",
        ${proxyTags.join('\n')}
        "direct"
      ],
      "tag": "Internet",
      "type": "selector"
    },
    {
      "interval": "1m0s",
      "outbounds": [
        ${proxyTags.join('\n')}
        "direct"
      ],
      "tag": "Best Latency",
      "type": "urltest",
      "url": "https://detectportal.firefox.com/success.txt"
    },
    ${allProxies.join(',\n')},
    {
      "tag": "direct",
      "type": "direct"
    },
    {
      "tag": "bypass",
      "type": "direct"
    },
    {
      "tag": "block",
      "type": "block"
    },
    {
      "tag": "dns-out",
      "type": "dns"
    }
  ],
  "route": {
    "auto_detect_interface": true,
    "rules": [
      {
        "outbound": "dns-out",
        "port": [
          53
        ]
      },
      {
        "inbound": [
          "dns-in"
        ],
        "outbound": "dns-out"
      },
      {
        "network": [
          "udp"
        ],
        "outbound": "block",
        "port": [
          443
        ],
        "port_range": []
      },
      {
        "ip_cidr": [
          "224.0.0.0/3",
          "ff00::/8"
        ],
        "outbound": "block",
        "source_ip_cidr": [
          "224.0.0.0/3",
          "ff00::/8"
        ]
      }
    ]
  }
}`;
        }
        // V2Ray format - process each proxy individually
        else {
            for (const line of limitedProxies) {
                const parts = line.split(',');
                if (parts.length < 3) continue;
                
                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;
                const isp = ispParts.join(' ') || 'Unknown';
                
                // If we have multiple bugs, create configs for each bug
                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];
                
                for (const bug of bugsToUse) {
                    // Determine domain, host, and SNI for this specific bug
                    let bugDomain, bugHost, bugSni;
                    
                    switch (bugType) {
                        case 'default':
                            bugDomain = mainDomain;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'non-wildcard':
                            bugDomain = bug;
                            bugHost = mainDomain;
                            bugSni = mainDomain;
                            break;
                        case 'wildcard':
                            bugDomain = bug;
                            bugHost = `${bug}.${mainDomain}`;
                            bugSni = `${bug}.${mainDomain}`;
                            break;
                    }
                    
                    let config;
                    // Remove bugLabel for V2Ray format
                    
                    switch (type) {
                        case 'vless': 
                            const vlessLabel = formatLabel(countryCode, isp, 'VLESS', tls);
                            config = `vless://${uuid}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(vlessLabel)}`;
                            break;
                        
                        case 'vmess': 
                            const vmessConfig = createVMessConfig(uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, countryCode, isp, tls);
                            const vmessString = JSON.stringify(vmessConfig);
                            config = `vmess://${safeBase64Encode(vmessString)}`;
                            break;
                        
                        case 'trojan': 
                            const trojanLabel = formatLabel(countryCode, isp, 'TROJAN', tls);
                            config = `trojan://${uuid}@${bugDomain}:${tls ? 443 : 80}?security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(trojanLabel)}`;
                            break;
                        
                        case 'shadowsocks': 
                            const ssLabel = formatLabel(countryCode, isp, 'SS', tls);
                            const ssAuth = `none:${uuid}`;
                            config = `ss://${safeBase64Encode(ssAuth)}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(ssLabel)}`;
                            break;
                        
                        case 'mix': 
                            // For mix, we'll create all protocol types with appropriate labels
                            const vmessConfigMix = createVMessConfig(uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, countryCode, isp, tls);
                            const vmessStringMix = JSON.stringify(vmessConfigMix);
                            
                            const vlessLabelMix = formatLabel(countryCode, isp, 'VLESS', tls);
                            const trojanLabelMix = formatLabel(countryCode, isp, 'TROJAN', tls);
                            const ssLabelMix = formatLabel(countryCode, isp, 'SS', tls);
                            
                            const ssAuthMix = `none:${uuid}`;

                            config = [
                                `vless://${uuid}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(vlessLabelMix)}`,
                                `vmess://${safeBase64Encode(vmessStringMix)}`,
                                `trojan://${uuid}@${bugDomain}:${tls ? 443 : 80}?security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(trojanLabelMix)}`,
                                `ss://${safeBase64Encode(ssAuthMix)}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(ssLabelMix)}`
                            ].join('\n');
                            break;
                    }
                    
                    if (config) {
                        results.push(config);
                    }
                }
            }
            
            return results.join('\n');
        }
    } catch (error) {
        console.error("Error generating subscription:", error);
        throw error;
    }
}
    
    // UI Interaction
    document.addEventListener('DOMContentLoaded', () => {
        // Populate regions from GitHub when the page loads
        populateRegionsFromGitHub();

        // Populate main domains from the constant array
        const mainDomainSelect = document.getElementById('mainDomain');
        MainDomains.forEach(domain => {
            const option = document.createElement('option');
            option.value = domain;
            option.textContent = domain;
            mainDomainSelect.appendChild(option);
        });

    
        const form = document.getElementById('subLinkForm');
        const loadingEl = document.getElementById('loading');
        const resultEl = document.getElementById('result');
        const outputEl = document.getElementById('output');
        const copyLinkBtn = document.getElementById('copyLink');
        const errorMessageEl = document.getElementById('error-message');
        const generateUuidBtn = document.getElementById('generateUuid');
        const uuidInput = document.getElementById('uuid');
        const bugTypeSelect = document.getElementById('bugType');
        const customBugContainer = document.getElementById('customBugContainer');
        const validationStatusEl = document.getElementById('validation-status');
        
        // Show/hide custom bug field based on bug type
        bugTypeSelect.addEventListener('change', () => {
            if (bugTypeSelect.value === 'default') {
                customBugContainer.style.display = 'none';
            } else {
                customBugContainer.style.display = 'block';
            }
        });
        
        // Form submission handler
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const type = document.getElementById('configType').value;
            const uuid = document.getElementById('uuid').value.trim();
            const bugType = document.getElementById('bugType').value;
            const mainDomain = document.getElementById('mainDomain').value;
            
            // Parse comma-separated custom bugs
            const customBugInput = document.getElementById('customBug').value.trim();
            const selectedBugs = customBugInput ? customBugInput.split(',').map(bug => bug.trim()) : [];
            
            const tls = document.getElementById('tls').value === 'true';
            const country = document.getElementById('country').value.trim() || null;
            const limit = document.getElementById('limit').value.trim() || null;
            const validateProxies = document.getElementById('validateProxies').checked;
            const formatType = document.getElementById('formatType').value;
            
            // Validation
            if (!uuid || !mainDomain) {
                errorMessageEl.textContent = 'ERROR: UUID and Main Domain are required';
                return;
            }
            
            if ((bugType === 'non-wildcard' || bugType === 'wildcard') && selectedBugs.length === 0) {
                errorMessageEl.textContent = 'ERROR: At least one Custom Bug is required for Non-Wildcard and Wildcard modes';
                return;
            }
            
            try {
                // Reset UI
                validationStatusEl.style.display = 'none';
                resultEl.style.display = 'none';
                errorMessageEl.textContent = '';
                
                // Update loading text based on validation setting
                const loadingTextEl = document.querySelector('.loading-text');
                loadingTextEl.textContent = validateProxies ? 
                    'Fetching proxy data and preparing to validate...' : 
                    'Fetching proxy data and generating configs...';
                
                // Show loading
                loadingEl.style.display = 'block';
                
                // Generate subscription
                const result = await generateV2raySub(
                    type, uuid, bugType, mainDomain, selectedBugs, tls, validateProxies, formatType, country, limit
                );
                
                // Hide loading
                loadingEl.style.display = 'none';
                
                // Display result
                outputEl.value = result;
                resultEl.style.display = 'block';
            } catch (error) {
                loadingEl.style.display = 'none';
                validationStatusEl.style.display = 'none';
                errorMessageEl.textContent = 'ERROR: ' + error.message;
                console.error(error);
            }
        });
        
        // Copy functionality
        copyLinkBtn.addEventListener('click', () => {
            outputEl.select();
            document.execCommand('copy');
            
            const originalText = copyLinkBtn.textContent;
            copyLinkBtn.textContent = '✓ COPIED SUCCESSFULLY';
            copyLinkBtn.style.background = 'linear-gradient(90deg, var(--color-success), var(--color-success))';
            
            setTimeout(() => {
                copyLinkBtn.textContent = originalText;
                copyLinkBtn.style.background = 'linear-gradient(90deg, var(--color-success), var(--color-primary))';
            }, 2000);
        });
    });
</script>
</body>
</html>
