<html lang="en"> <head>     <link rel="icon" href="https://raw.githubusercontent.com/jaka2m/mau/refs/heads/kepo/G.png" type="image/png">    <meta property="og:title" content="Stupid World" />    <meta property="og:description" content="Create your V2Ray account effortlessly and experience a secure, anonymous internet connection. Protect your privacy and enjoy unrestricted access to content from anywhere in the world." />    <meta property="og:image" content="https://raw.githubusercontent.com/jaka2m/mau/refs/heads/kepo/geo.png" />    <meta property="og:image:secure_url" content="https://raw.githubusercontent.com/jaka2m/mau/refs/heads/kepo/geo.png"/>    <meta property="og:url" content="https://vpn.stupidworld.web.id/" />    <meta property="og:type" content="website" />    <!-- Twitter Card Meta Tags -->    <meta name="twitter:card" content="summary_large_image" />    <meta name="twitter:title" content="VLESS VMESS TROJAN SHADOESOCKS" />    <meta name="twitter:description" content="Create your V2Ray account effortlessly and experience a secure, anonymous internet connection. Protect your privacy and enjoy unrestricted access to content from anywhere in the world." />    <meta name="twitter:image" content="https://raw.githubusercontent.com/jaka2m/mau/refs/heads/kepo/geo.png" />    <meta property="twitter:image:secure_url" content="https://raw.githubusercontent.com/jaka2m/mau/refs/heads/kepo/geo.png"/>    <meta name="twitter:url" content="https://joss.checker-ip.xyz/" />  <meta charset="utf-8"/>  <meta content="width=device-width, initial-scale=1" name="viewport"/>  <title>   GEO - PROJECT  </title>  <script src="https://cdn.tailwindcss.com">  </script>  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"/>  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap" rel="stylesheet"/>    <style>:root {    --color-bg: #050a18;    --color-bg-card: #0a1128;    --color-primary: #00ddff;    --color-secondary: #7700ff;    --color-accent: #ff00aa;    --color-text: #e0f7ff;    --color-text-dim: #8ba3b8;    --color-success: #00ffaa;    --color-error: #ff2266;    --color-input-bg: rgba(0, 221, 255, 0.05);    --color-input-border: rgba(0, 221, 255, 0.2);    --glow-primary: 0 0 10px rgba(0, 221, 255, 0.5), 0 0 20px rgba(0, 221, 255, 0.2);    --glow-secondary: 0 0 10px rgba(119, 0, 255, 0.5), 0 0 20px rgba(119, 0, 255, 0.2);    --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);    --card-width: 100%;    --card-max-width: 480px;    --card-padding: 1.5rem;    --card-border-radius: 12px;}* {    margin: 0;    padding: 0;    box-sizing: border-box;}:root {    --color-bg: #0f0f0f; /* terminal dark */    --color-grid: #00ff00; /* neon green */    --color-text: #00ff00;    --color-accent: #00cc00;    --card-width: 100%;    --card-max-width: 720px;    --font-mono: 'Courier New', Courier, monospace;}body {    background-color: var(--color-bg);    color: var(--color-text);    font-family: var(--font-mono);    margin: 0;    padding: 0;    line-height: 1.5;    overflow-x: hidden;}body::before {    content: "";    position: fixed;    top: 0;    left: 0;    width: 100%;    height: 100%;    background-image:         linear-gradient(90deg, var(--color-grid) 1px, transparent 1%) center,        linear-gradient(var(--color-grid) 1px, transparent 1%) center;    background-size: 22px 22px;    background-color: transparent;    opacity: 0.05;    z-index: -1;}.container {    width: var(--card-width);    max-width: var(--card-max-width);    padding: 1rem;    margin: 1rem auto;    background-color: rgba(0, 255, 0, 0.05);    border: 1px solid var(--color-accent);    border-radius: 8px;    box-shadow: 0 0 10px #00ff00aa;}:root {    --color-bg: #0d0d0d;    --color-bg-card: #111;    --color-text: #00ff00;    --color-accent: #00cc00;    --card-border-radius: 6px;    --card-padding: 1rem;    --card-glow: 0 0 10px #00ff00;}body {    background-color: var(--color-bg);    color: var(--color-text);    font-family: 'Courier New', Courier, monospace;    margin: 0;    padding: 0;}.card {    background: var(--color-bg-card);    border-radius: var(--card-border-radius);    padding: var(--card-padding);    box-shadow: var(--card-glow);    border: 1px solid rgba(0, 255, 0, 0.1);    color: var(--color-text);    width: 100%;    position: relative;    overflow: hidden;}.card::before,.footer::before {    content: "";    position: absolute;    top: 0;    left: 0;    height: 2px;    width: 100%;    background: linear-gradient(90deg, #00ff00, #00cc00, #009900);    opacity: 0.3;}.card::after,.footer::after {    content: "";    position: absolute;    top: 2px;    left: 0;    width: 100%;    height: 1px;    background: #00ff0055;    filter: blur(1px);    opacity: 0.2;}/* Title container and text with Matrix/Hacker theme */.title-container {    text-align: center;    margin-bottom: 1.5rem;    position: relative;}.title {    font-family: "Orbitron", sans-serif;    font-weight: 700;    font-size: 1.8rem;    letter-spacing: 1px;    margin: 0;    background: linear-gradient(90deg, rgba(0, 255, 0, 0.8), rgba(50, 255, 50, 0.6)); /* Darker green for a more subtle effect */    -webkit-background-clip: text;    background-clip: text;    -webkit-text-fill-color: transparent;    position: relative;    display: inline-block;    text-shadow: 0 0 10px rgba(0, 255, 0, 0.6), 0 0 15px rgba(0, 255, 0, 0.4); /* Reduced glow effect for a cleaner look */}.title::after {    content: "";    position: absolute;    top: -8px;    right: -30px;    font-size: 0.7rem;    font-weight: 400;    background: rgba(0, 255, 0, 0.4); /* Slightly darker neon green for subtler effect */    color: #000000;    padding: 2px 5px;    border-radius: 3px;    -webkit-text-fill-color: #000000;    transform: rotate(15deg);    text-shadow: 0 0 10px rgba(0, 255, 0, 0.7), 0 0 15px rgba(0, 255, 0, 0.3); /* Adjusted glow for more realistic look */    animation: matrix-text 1.5s infinite;}/* Keyframes for Matrix-style text effect */@keyframes matrix-text {    0% {        content: "HOME";    }    20% {        content: "CONVERT";    }    40% {        content: "SUB";    }    60% {        content: "CHECKER";    }    80% {        content: "GENERATE";    }    100% {        content: "HOME";    }}/* Hidden class for content visibility */.hidden {    visibility: hidden;}:root {    --color-bg: #0d0d0d;    --color-text: #00ff00;    --color-input-bg: #111;    --color-input-border: #00ff0055;    --color-input-focus: #00ff00;    --glow-primary: 0 0 6px #00ff00;    --transition: 0.2s ease-in-out;}.form-group {    margin-bottom: 1.2rem;    position: relative;}.form-group label {    display: block;    margin-bottom: 0.3rem;    font-weight: bold;    font-size: 0.95rem;    color: var(--color-text);    letter-spacing: 0.5px;    font-family: 'Courier New', monospace;}.form-control {    width: 100%;    padding: 0.7rem 0.8rem;    background: var(--color-input-bg);    border: 1px solid var(--color-input-border);    border-radius: 4px;    color: var(--color-text);    font-family: 'Courier New', monospace;    font-size: 0.95rem;    font-weight: normal;    transition: var(--transition);}.form-control:focus {    outline: none;    border-color: var(--color-input-focus);    box-shadow: var(--glow-primary);}select.form-control {    appearance: none;    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%2300ff00' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");    background-repeat: no-repeat;    background-position: right 0.8rem center;    background-size: 1rem;    padding-right: 2.2rem;}:root {    --color-bg: #0d0d0d;    --color-text: #00ff00;    --color-btn-bg: #111;    --color-btn-border: #00ff00;    --glow-primary: 0 0 10px #00ff00;    --transition: 0.2s ease-in-out;}.btn {    width: 100%;    padding: 0.8rem;    background: var(--color-btn-bg);    color: var(--color-text);    border: 1px solid var(--color-btn-border);    border-radius: 4px;    font-family: 'Courier New', monospace;    font-weight: bold;    font-size: 1rem;    letter-spacing: 1px;    cursor: pointer;    transition: var(--transition);    position: relative;    overflow: hidden;    text-transform: uppercase;}.btn::before {    content: "";    position: absolute;    top: 0;    left: -100%;    width: 100%;    height: 100%;    background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.2), transparent);    transition: 0.5s;}.btn:hover::before {    left: 100%;}.btn:hover {    box-shadow: var(--glow-primary);    transform: translateY(-2px);}:root {    --color-bg: #0d0d0d;    --color-text: #00ff00;    --color-accent: #00cc00;    --color-success: #00ff00;    --glow-primary: 0 0 10px #00ff00;}.loading {    display: none;    text-align: center;    margin: 1.5rem 0;    color: var(--color-text);    font-family: 'Courier New', monospace;}.spinner {    display: inline-block;    width: 40px;    height: 40px;    border: 3px solid rgba(0, 255, 0, 0.1);    border-radius: 50%;    border-top-color: var(--color-text);    animation: spin 1s ease-in-out infinite;}@keyframes spin {    to { transform: rotate(360deg); }}.loading-text {    margin-top: 0.8rem;    font-family: 'Courier New', monospace;    font-size: 0.9rem;    letter-spacing: 1px;    color: var(--color-text);}.result {    display: none;    margin-top: 1.5rem;    position: relative;    color: var(--color-text);    font-family: 'Courier New', monospace;    background: #111;    border: 1px solid #00ff0044;    padding: 1rem;    border-radius: 4px;    box-shadow: 0 0 6px #00ff0044;}.result-header {    display: flex;    justify-content: space-between;    align-items: center;    margin-bottom: 0.8rem;}.result-title {    font-size: 1.1rem;    font-weight: bold;    color: var(--color-success);    text-transform: uppercase;}:root {    --color-bg: #0d0d0d;    --color-text: #00ff00;    --color-input-border: #00ff00;    --color-error: #ff0033;    --glow-primary: 0 0 8px #00ff00;}.output-container {    position: relative;    margin-bottom: 0.8rem;}.output {    width: 100%;    height: 180px;    background: #111;    border: 1px solid var(--color-input-border);    border-radius: 4px;    color: var(--color-text);    padding: 0.8rem;    font-family: 'Courier New', monospace;    font-size: 0.85rem;    resize: vertical;    line-height: 1.4;    box-shadow: 0 0 6px rgba(0, 255, 0, 0.1);}.output:focus {    outline: none;    border-color: var(--color-input-border);    box-shadow: var(--glow-primary);}.error-message {    color: var(--color-error);    text-align: center;    margin-top: 0.8rem;    font-family: 'Courier New', monospace;    font-size: 0.9rem;    font-weight: bold;}/* Responsive adjustments */@media (max-width: 480px) {    :root {        --card-padding: 1.2rem;    }    .container {        padding: 0 0.5rem;    }    .title {        font-size: 1.5rem;        color: #00ff00;        font-family: 'Courier New', monospace;    }    .subtitle {        font-size: 0.8rem;        color: #00ff00;        font-family: 'Courier New', monospace;    }    .form-group label {        font-size: 0.9rem;        color: #00ff00;        font-family: 'Courier New', monospace;    }    .form-control {        padding: 0.6rem 0.7rem;        font-size: 0.9rem;        background: #111;        border: 1px solid #00ff00;        color: #00ff00;        font-family: 'Courier New', monospace;    }    .btn {        padding: 0.7rem;        font-size: 0.9rem;        font-family: 'Courier New', monospace;        background: #000;        color: #00ff00;        border: 1px solid #00ff00;        box-shadow: 0 0 6px #00ff00;    }}/* Terminal Hacker Details */.tech-detail {    position: absolute;    background: #00ff00;    opacity: 0.08;    z-index: -1;    pointer-events: none;}.tech-detail-1 {    width: 40px;    height: 40px;    top: 20px;    right: 20px;    border-radius: 50%;    box-shadow: 0 0 15px #00ff0055;    background: #00ff00;}.tech-detail-2 {    width: 80px;    height: 2px;    bottom: 40px;    left: -20px;    transform: rotate(45deg);    background: #00ff00;    box-shadow: 0 0 6px #00ff0044;}.tech-detail-3 {    width: 15px;    height: 15px;    bottom: 20px;    right: 40px;    transform: rotate(45deg);    background: #00ff00;    box-shadow: 0 0 4px #00ff0044;}/* Animated typing effect for loading */.typing {    overflow: hidden;    white-space: nowrap;    border-right: 2px solid #00ff00; /* Hijau neon */    width: 0;    animation: typing 3s steps(30, end) infinite;    color: #00ff00; /* Teks hijau neon */}@keyframes typing {    0% { width: 0 }    80% { width: 100% }    100% { width: 100% }}/* UUID Generate Button */.form-group.uuid-group {    position: relative;}.uuid-generate {    position: absolute;    right: 8px;    top: 36px;    background: #111; /* Latar belakang gelap */    border: none;    color: #00ff00; /* Hijau neon */    padding: 4px 8px;    border-radius: 4px;    cursor: pointer;    font-size: 0.75rem;    transition: 0.2s;    box-shadow: 0 0 6px rgba(0, 255, 0, 0.2);}.uuid-generate:hover {    background: #222; /* Gelap saat hover */    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);}/* Form Row */.form-row {    display: flex;    gap: 0.8rem;    margin-bottom: 1.2rem;}.form-row .form-group {    flex: 1;    margin-bottom: 0;}.info-badge {    display: inline-block;    background: var(--color-accent);    color: var(--color-bg);    font-size: 0.65rem;    padding: 1px 5px;    border-radius: 3px;    margin-left: 5px;    vertical-align: middle;    font-weight: 600;}.custom-bug-container {    display: none;}/* Footer styles */.footer {  width: 100%;  max-width: 480px;  background: rgba(0, 0, 0, 0.8);  border-radius: 12px;  padding: 1.5rem;  position: relative;  border: 1px solid rgba(0, 255, 0, 0.2);  box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);  display: flex;  flex-direction: column;  align-items: center;  text-align: center;  overflow: hidden;  margin: 0 0.75rem;  font-family: "Share Tech Mono", monospace;  color: #00ff9c;}.footer::before {  content: "";  position: absolute;  top: 0;  left: 0;  height: 3px;  width: 100%;  background: linear-gradient(90deg, #00ff9c, #00ffcc, #39ff14);  animation: glitch-bar 4s infinite linear;}.footer::after {  content: "";  position: absolute;  bottom: 0;  left: 0;  height: 1px;  width: 100%;  background: linear-gradient(90deg, #00ff9c, transparent, #39ff14);  filter: blur(1px);}.footer-logo {  font-size: 1.2rem;  margin-bottom: 0.4rem;  background: linear-gradient(90deg, #00ffcc, #39ff14);  -webkit-background-clip: text;  -webkit-text-fill-color: transparent;  font-family: "Orbitron", sans-serif;  letter-spacing: 2px;}.footer-powered {  font-size: 0.75rem;  color: #00ff9c;  margin-bottom: 0.6rem;  opacity: 0.8;}.footer-social {  display: flex;  justify-content: center;  gap: 0.8rem;  margin-bottom: 0.6rem;  flex-wrap: wrap;}.social-link {  color: #00ffcc;  background: rgba(0, 255, 128, 0.05);  border: 1px solid rgba(0, 255, 128, 0.2);  padding: 0.25rem 0.6rem;  border-radius: 4px;  transition: all 0.3s ease;  display: flex;  align-items: center;  font-size: 0.8rem;}.social-link:hover {  background: rgba(0, 255, 128, 0.1);  box-shadow: 0 0 10px #00ff9c;  transform: translateY(-1px);}.footer-year {  font-size: 0.75rem;  color: #39ff14;  margin-top: 0.5rem;  letter-spacing: 1px;}@keyframes glitch-bar {  0% { transform: translateX(0); }  100% { transform: translateX(100%); }}/* Matrix / Hacker Circuit Line Effects */.circuit-line-1,.circuit-line-2,.circuit-line-3,.circuit-line-4 {  position: absolute;  background: #00ff9c;  box-shadow: 0 0 6px #00ff9c, 0 0 10px #00ff9c;  opacity: 0.2;  animation: flicker 4s infinite ease-in-out;}.circuit-line-1 {  width: 60px;  height: 1px;  top: 20px;  left: 20px;}.circuit-line-2 {  width: 1px;  height: 30px;  top: 20px;  left: 20px;}.circuit-line-3 {  width: 40px;  height: 1px;  bottom: 25px;  right: 30px;}.circuit-line-4 {  width: 1px;  height: 25px;  bottom: 25px;  right: 30px;}/* Neon Dots with Glow Effect */.circuit-dot {  position: absolute;  width: 4px;  height: 4px;  border-radius: 50%;  background: #00ff9c;  box-shadow: 0 0 6px #00ff9c, 0 0 12px #00ffcc;  animation: pulse-dot 3s infinite ease-in-out;  opacity: 0.8;}.circuit-dot-1 {  top: 20px;  left: 20px;}.circuit-dot-2 {  top: 50px;  left: 20px;}.circuit-dot-3 {  bottom: 25px;  right: 30px;}.circuit-dot-4 {  bottom: 50px;  right: 30px;}/* Neon Animations */@keyframes flicker {  0%, 100% {    opacity: 0.2;  }  50% {    opacity: 0.4;    box-shadow: 0 0 8px #00ffcc, 0 0 16px #00ffcc;  }}@keyframes pulse-dot {  0%, 100% {    transform: scale(1);    opacity: 0.8;  }  50% {    transform: scale(1.2);    opacity: 1;    box-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;  }}/* Override padding in Tailwind with matrix-style consistency */.p-4,.p-6 {  padding: 1rem !important;}/* Validation status styles */.validation-status {    display: none;    margin-top: 1rem;    font-family: 'Share Tech Mono', monospace;    font-size: 0.9rem;    color: var(--color-text-dim);}.validation-progress {    margin-top: 0.5rem;    height: 6px;    width: 100%;    background: rgba(0, 0, 0, 0.2);    border-radius: 3px;    overflow: hidden;}.validation-bar {    height: 100%;    width: 0%;    background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));    transition: width 0.3s ease;}.validation-stats {    display: flex;    justify-content: space-between;    margin-top: 0.5rem;    font-size: 0.8rem;}.validation-check {    margin-right: 0.5rem;    display: inline-block;    width: 16px;    height: 16px;}.form-group.validation-group {    display: flex;    align-items: center;    margin-bottom: 1rem;}.form-check {    display: flex;    align-items: center;    cursor: pointer;}.form-check-input {    margin-right: 0.5rem;    cursor: pointer;    width: 16px;    height: 16px;    accent-color: var(--color-primary);}.form-check-label {    font-size: 0.9rem;    cursor: pointer;}.select-info {    font-size: 0.75rem;    color: var(--color-text-dim);    margin-top: 0.3rem;    font-style: italic;}/* Download Button Styles */.download-btn {    margin-top: 10px;    padding: 10px 16px;    font-family: 'Orbitron', sans-serif;    font-weight: 600;    border-radius: 6px;    background: rgba(0, 255, 0, 0.15); /* Hijau neon yang lebih lembut */    border: 1px solid rgba(0, 255, 0, 0.5); /* Border hijau neon yang lebih lembut */    color: #00ff00; /* Hijau neon untuk teks */    display: inline-flex;    align-items: center;    gap: 8px;    cursor: pointer;    transition: all 0.3s ease;    backdrop-filter: blur(10px);    -webkit-backdrop-filter: blur(10px);    box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3); /* Cahaya hijau lebih subtle */}.download-btn:hover {    background: rgba(0, 255, 0, 0.3); /* Hover hijau neon yang lebih terang */    border-color: rgba(0, 255, 0, 0.7); /* Hover border lebih cerah */    box-shadow: 0 6px 28px rgba(0, 255, 0, 0.35); /* Cahaya hijau terang saat hover */    transform: translateY(-2px);}.download-icon {    width: 18px;    height: 18px;    filter: invert(1); /* Membuat ikon terlihat lebih terang dengan latar belakang hijau */}/* Copy Button Styles */.copy-btn {    margin-top: 10px;    padding: 10px 16px;    font-family: 'Orbitron', sans-serif;    font-weight: 600;    border-radius: 6px;    background: rgba(0, 255, 0, 0.15); /* Hijau neon lembut */    border: 1px solid rgba(0, 255, 0, 0.5); /* Border hijau neon lebih halus */    color: #00ff00; /* Teks hijau neon */    display: inline-flex;    align-items: center;    gap: 8px;    cursor: pointer;    transition: all 0.3s ease;    backdrop-filter: blur(10px);    -webkit-backdrop-filter: blur(10px);    box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3); /* Cahaya hijau neon */}.copy-btn:hover {    background: rgba(0, 255, 0, 0.3); /* Hover lebih terang */    border-color: rgba(0, 255, 0, 0.7); /* Border lebih cerah saat hover */    box-shadow: 0 6px 28px rgba(0, 255, 0, 0.35); /* Cahaya hijau terang saat hover */    transform: translateY(-2px);}.copy-icon {    width: 18px;    height: 18px;    filter: invert(1); /* Membuat ikon lebih terang dengan latar belakang hijau */}.action-buttons {    display: flex;    justify-content: space-between;    align-items: center;    gap: 12px;    margin-top: 12px;    flex-wrap: wrap;}.copy-btn, .download-btn {    flex: 1;    justify-content: center;    text-align: center;}/* QR Code Button Styles */.qrcode-btn {    display: inline-flex;    align-items: center;    justify-content: center;    margin: 20px auto;    padding: 10px 16px;    font-family: 'Orbitron', sans-serif;    font-weight: 600;    border-radius: 6px;    background: rgba(0, 255, 0, 0.15); /* Hijau neon lembut */    border: 1px solid rgba(0, 255, 0, 0.5); /* Border hijau neon lebih halus */    color: #00ff00; /* Teks hijau neon */    gap: 8px;    cursor: pointer;    transition: all 0.3s ease;    backdrop-filter: blur(10px);    -webkit-backdrop-filter: blur(10px);    box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3); /* Cahaya hijau neon */    display: flex;}.qrcode-btn:hover {    background: rgba(0, 255, 0, 0.25); /* Hover lebih terang */    border-color: rgba(0, 255, 0, 0.7); /* Border lebih cerah saat hover */    box-shadow: 0 6px 28px rgba(0, 255, 0, 0.35); /* Cahaya hijau terang saat hover */    transform: translateY(-2px);}.qrcode-icon {    width: 18px;    height: 18px;    transition: all 0.3s ease;    filter: invert(1); /* Mengubah warna ikon menjadi terang dengan latar belakang hijau */}.qrcode-icon:hover {    transform: scale(1.2);}.center {    display: flex;    justify-content: center;}  footer {    position: fixed;    bottom: 0;    left: 0;    width: 100%;    background: rgba(0, 0, 0, 0.85); /* Latar gelap seperti terminal */    color: #00ff00; /* Teks hijau neon ala hacker */    font-size: 13px;    font-family: 'Share Tech Mono', monospace; /* Font terminal */    font-weight: 500;    text-align: center;    padding: 10px 0;    border-top: 1px solid rgba(0, 255, 0, 0.2); /* Garis atas neon subtle */    box-shadow: 0 -2px 10px rgba(0, 255, 0, 0.1); /* Efek glow atas */    z-index: 1000;}.spacer {    margin-top: 50px;  }    .copy-btn,.list-btn,.download-btn,.qrcode-btn {  font-size: 0.6rem;  padding: 9px 10px;  text-decoration: none;  display: inline-flex;  align-items: center;  justify-content: center;  margin: 0 auto;}.qrcode-btn i,.copy-btn i,.list-btn i,.download-btn i {  margin-right: 5px;}.nav-buttons {  display: flex;  justify-content: center;  gap: 8px;  margin-bottom: 20px;  flex-wrap: wrap;  padding: 15px 0;}.nav-button {  background: rgba(0, 255, 0, 0.15);  border: 1px solid rgba(0, 255, 0, 0.3);  color: rgba(0, 255, 0, 0.85);  font-family: 'Share Tech Mono', monospace;  padding: 6px 12px;  border-radius: 20px;  font-size: 0.85rem;  transition: all 0.3s ease;  text-decoration: none;  display: flex;  align-items: center;  gap: 5px;  box-shadow: 0 0 6px rgba(0, 255, 0, 0.4);}.nav-button:hover {  background: rgba(0, 255, 0, 0.25);  color: #ffffff;  transform: translateY(-2px);  box-shadow: 0 0 12px rgba(0, 255, 0, 0.6);  border-color: rgba(0, 255, 0, 0.5);}.nav-button.active {  background: linear-gradient(90deg, #00ff00, #00cc33, #009900);  color: white;  border: none;  box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);}</style></head><body>    <div class="container">        <div class="card">            <div class="tech-detail tech-detail-1"></div>            <div class="tech-detail tech-detail-2"></div>            <div class="tech-detail tech-detail-3"></div>                        <div class="title-container">                <h1 class="title">GEO - PROJECT</h1>                <p class="subtitle">Advanced Subscription Link Generator</p>            </div>            <div class="nav-buttons">                <a href="/" class="nav-button">                    <i class="fas fa-home"></i> Home                </a>                <a href="sub" class="nav-button active">                    <i class="fas fa-rss"></i> Subscription                </a>                <a href="link" class="nav-button">                    <i class="fas fa-link"></i> Link Generator                </a>                <a href="converter" class="nav-button">                    <i class="fas fa-exchange-alt"></i> Converter                </a>                <a href="checker" class="nav-button">                    <i class="fas fa-cloud"></i> IP Checker                </a>                            <form id="subLinkForm">                <div class="form-group">                    <label for="configType" style="font-weight: bold;">PROTOCOL TYPE</label>                    <select id="configType" class="form-control" required>                        <option value="vless">VLESS</option>                        <option value="vmess">VMESS</option>                        <option value="trojan">TROJAN</option>                        <option value="shadowsocks">SHADOWSOCKS</option>                        <option value="mix">MIX (ALL PROTOCOLS)</option>                    </select>                </div>                <div class="form-group">                <label for="formatType">FORMAT TYPE</label>                <select id="formatType" class="form-control" required>                    <option value="v2ray">V2RAY</option>                    <option value="clash">CLASH</option>                    <option value="singbox">SINGBOX</option>                    <option value="singboxxl">SINGBOX V1.10.3 (cocok buat paket xl)</option>                    <option value="nekobox">NEKOBOX</option>                    <option value="husi">HUSI</option>                </select>            </div>                            <label for="uuid" style="font-weight: bold;">UUID</label>                <input type="text" id="uuid" class="form-control" value="f282b878-8711-45a1-8c69-5564172123c1" required>                <button type="button" id="generateUuid" class="uuid-generate" style="display: none;">GENERATE</button>                <div class="form-group">                    <label for="bugType" style="font-weight: bold;">BUG TYPE</label>                    <select id="bugType" class="form-control" required>                        <option value="default">DEFAULT</option>                        <option value="non-wildcard">NON-WILDCARD</option>                        <option value="wildcard">WILDCARD</option>                    </select>                </div>                                <div class="form-group">                    <label for="mainDomain" style="font-weight: bold;">MAIN DOMAIN <span class="info-badge">SELECT</span></label>                    <select id="mainDomain" class="form-control" required></select>                </div>                                <div id="customBugContainer" class="form-group custom-bug-container">                    <label for="customBug" style="font-weight: bold;">CUSTOM BUG</label>                    <input type="text" id="customBug" class="form-control" placeholder="e.g., google.com, youtube.com, instagram.com">                    <div class="select-info">Separate multiple domains with commas</div>                </div>                                <div class="form-group">                    <label for="tls" style="font-weight: bold;">TLS ENCRYPTION</label>                    <select id="tls" class="form-control">                        <option value="true">ENABLED</option>                        <option value="false">DISABLED</option>                    </select>                </div>                                <div class="form-row">                    <div class="form-group">                        <label for="country" style="font-weight: bold;">REGION FILTER</label>                        <select id="country" class="form-control">                            <option value="">Loading regions...</option>                        </select>                    </div>                                        <div class="form-group">                        <label for="limit" style="font-weight: bold;">QUANTITY</label>                        <input type="number" id="limit" class="form-control" min="1" max="100" value="5" placeholder="Max 20" required>                    </div>                </div>                                <div class="form-group validation-group">                    <label class="form-check">                        <input type="checkbox" id="validateProxies" class="form-check-input" checked>                        <span class="form-check-label" style="font-weight: bold;">Validate proxies before generating</span>                    </label>                </div>                                <button type="submit" class="btn" style="font-weight: bold;">Generate Configuration</button>            </form>                        <div id="loading" class="loading">                <div class="spinner"></div>                <div class="loading-text typing" style="font-weight: bold;">Fetching proxy data and generating configs...</div>            </div>                        <div id="validation-status" class="validation-status">                <div style="font-weight: bold;">Validating proxies... <span id="validation-count">0/0</span></div>                <div class="validation-progress">                    <div id="validation-bar" class="validation-bar"></div>                </div>                <div class="validation-stats">                    <div style="font-weight: bold;">Valid: <span id="valid-count">0</span></div>                    <div>Invalid: <span id="invalid-count">0</span></div>                </div>            </div>                        <div id="error-message" class="error-message"></div>                        <div id="result" class="result">                <div class="result-header">                    <div class="result-title" style="font-weight: bold;">CONFIGURATION GENERATED</div>                </div>                <div class="output-container">                    <textarea id="output" class="output" readonly></textarea>                </div>                <div class="action-buttons">                    <button id="copyLink" class="copy-btn">                        <svg class="copy-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>                        </svg>                        COPY                    </button><button id="downloadConfig" class="download-btn">    <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>        <polyline points="7 10 12 15 17 10"/>        <line x1="12" y1="15" x2="12" y2="3"/>    </svg>    DOWNLOAD</button><button id="generateQR" class="qrcode-btn">    <i class="bi bi-qr-code"></i>    QR CODE (v2rayNG)  </button></div></div>  </div><div class="spacer"></div><footer>  <div class="circuit-line circuit-line-1"></div>  <div class="circuit-line circuit-line-2"></div>  <div class="circuit-line circuit-line-3"></div>  <div class="circuit-line circuit-line-4"></div>  <div class="circuit-dot circuit-dot-1"></div>  <div class="circuit-dot circuit-dot-2"></div>  <div class="circuit-dot circuit-dot-3"></div>  <div class="circuit-dot circuit-dot-4"></div>  <div class="footer-powered" style="font-weight: bold;">POWERED BY SECURE TECHNOLOGY</div>  <div class="footer-logo" style="font-weight: bold;">    <a href="https://t.me/sampiiiiu" target="_blank" style="color: inherit; text-decoration: none;">      GEO-PROJECT    </a>  </div></footer><script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.min.js"></script><script>document.getElementById('downloadConfig').addEventListener('click', function () {    const configContent = document.getElementById('output').value;    const format = document.getElementById('formatType').value;    let extension = '';    let prefix = '';    let mimeType = '';        switch (format) {        case 'clash':            extension = 'yaml';            prefix = 'clash';            mimeType = 'application/x-yaml';            break;        case 'singbox':            extension = 'bpf';            prefix = 'singbox';            mimeType = 'application/octet-stream';            break;        case 'nekobox':            extension = 'json';            prefix = 'nekobox';            mimeType = 'application/json';            break;        case 'v2ray':            extension = 'txt';            prefix = 'v2ray';            mimeType = 'text/plain';            break;        default:            alert('Format tidak dikenali!');            return;    }    const randomNum = Math.floor(1000 + Math.random() * 9000); // 4 digit random    const filename = `${prefix}-${randomNum}.${extension}`;    const blob = new Blob([configContent], { type: mimeType });    const downloadLink = document.createElement('a');    downloadLink.href = URL.createObjectURL(blob);    downloadLink.download = filename;    document.body.appendChild(downloadLink);    downloadLink.click();    document.body.removeChild(downloadLink);});</script><script>    document.getElementById('generateQR').addEventListener('click', function () {        const input = document.getElementById('output').value.trim();        const urls = input.split('\n').filter(url =>            url.startsWith("vmess://") ||            url.startsWith("vless://") ||            url.startsWith("trojan://") ||            url.startsWith("ss://") ||            url.startsWith("v2ray://") ||            url.startsWith("v2rayng://")        );        if (urls.length === 0) {            alert("No valid config URLs found.");            return;        }        document.querySelectorAll('.qr-modal').forEach(modal => modal.remove());        const maxLength = 2950;        let chunks = [];        let tempChunk = "";        for (let i = 0; i < urls.length; i++) {            if ((tempChunk + urls[i] + "\n").length > maxLength) {                chunks.push(tempChunk.trim());                tempChunk = urls[i] + "\n";            } else {                tempChunk += urls[i] + "\n";            }        }        if (tempChunk) chunks.push(tempChunk.trim());        // Generate QR Code as Canvas        function generateQRCodeCanvas(text) {            const qr = qrcode(0, 'L');            qr.addData(text);            qr.make();            const canvas = document.createElement('canvas');            const cellSize = 3;            const margin = 4;            const size = qr.getModuleCount() * cellSize + margin * 2;            canvas.width = canvas.height = size;            const ctx = canvas.getContext('2d');            // background putih            ctx.fillStyle = '#ffffff';            ctx.fillRect(0, 0, size, size);            // QR hitam-putih            for (let row = 0; row < qr.getModuleCount(); row++) {                for (let col = 0; col < qr.getModuleCount(); col++) {                    ctx.fillStyle = qr.isDark(row, col) ? '#000000' : '#ffffff';                    ctx.fillRect(margin + col * cellSize, margin + row * cellSize, cellSize, cellSize);                }            }            return canvas;        }        if (chunks.length === 1) {            // Single QR Modal            const modal = document.createElement('div');            modal.className = 'qr-modal modal-dialog-centered';            modal.style = `                position: fixed;                top: 50%;                left: 50%;                transform: translate(-50%, -50%);                background: rgba(255, 255, 255, 0.15);                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);                backdrop-filter: blur(12px);                -webkit-backdrop-filter: blur(12px);                border-radius: 20px;                padding: 17px;                z-index: 9999;                text-align: center;                border: 1px solid rgba(255, 255, 255, 0.3);            `;            const qrCanvas = generateQRCodeCanvas(chunks[0]);            qrCanvas.style.width = '288px';            qrCanvas.style.height = '288px';            const downloadBtn = document.createElement('button');            downloadBtn.classList.add('btn', 'btn-success', 'mt-2');            downloadBtn.innerText = 'Download QR';            downloadBtn.onclick = () => {                const link = document.createElement('a');                link.download = 'qr_code.jpg';                link.href = qrCanvas.toDataURL('image/jpeg');                link.click();            };            const closeBtn = document.createElement('button');            closeBtn.classList.add('btn', 'btn-danger');            closeBtn.style.marginTop = '10px'; // Bisa diubah sesuai kebutuhan            closeBtn.innerText = 'Close';            closeBtn.onclick = () => modal.remove();            modal.appendChild(qrCanvas);            modal.appendChild(downloadBtn);            modal.appendChild(closeBtn);            document.body.appendChild(modal);        } else {            // Multiple QR Modal            let currentIndex = 0;            const modal = document.createElement('div');            modal.className = 'qr-modal modal-dialog-centered';            modal.style = `                position: fixed;                top: 50%;                left: 50%;                transform: translate(-50%, -50%);                background: rgba(255, 255, 255, 0.15);                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);                backdrop-filter: blur(12px);                -webkit-backdrop-filter: blur(12px);                border-radius: 20px;                padding: 20px;                z-index: 9999;                text-align: center;                border: 1px solid rgba(255, 255, 255, 0.3);            `;            const label = document.createElement('div');            label.style.marginBottom = "10px";            label.style.fontWeight = "bold";            const qrContainer = document.createElement('div');            const btnPrev = document.createElement('button');btnPrev.classList.add('btn', 'btn-secondary');btnPrev.innerText = 'Prev';btnPrev.style.marginRight = '10px'; const btnNext = document.createElement('button');btnNext.classList.add('btn', 'btn-secondary');btnNext.innerText = 'Next';const navContainer = document.createElement('div');navContainer.style.display = 'flex';navContainer.style.justifyContent = 'space-between';navContainer.style.marginTop = '10px';navContainer.appendChild(btnPrev);navContainer.appendChild(btnNext);const closeBtn = document.createElement('button');closeBtn.classList.add('btn', 'btn-danger', 'mt-2');closeBtn.innerText = 'Close';closeBtn.style.display = 'block';closeBtn.style.margin = '10px auto 0';            modal.appendChild(label);            modal.appendChild(qrContainer);            modal.appendChild(navContainer);            modal.appendChild(closeBtn);            document.body.appendChild(modal);            // Update QR and download for each chunk            function updateQR(index) {                const qrCanvas = generateQRCodeCanvas(chunks[index]);                qrCanvas.style.width = '288px';                 qrCanvas.style.height = '288px';                // Update QR image in modal                qrContainer.innerHTML = '';                qrContainer.appendChild(qrCanvas);                // Update label for QR navigation                label.innerHTML = `                    <span style="color: blue;">QR</span>                    <span style="color: blue;">${index + 1}</span>                    <span style="color: green;">dari</span>                    <span style="color: blue;">${chunks.length}</span>                `;                const downloadBtn = document.createElement('button');                downloadBtn.classList.add('btn', 'btn-success', 'mt-2');                downloadBtn.innerText = 'Download QR';                downloadBtn.onclick = () => {                    const link = document.createElement('a');                    link.download = `qr_code_${index + 1}.jpg`;                    link.href = qrCanvas.toDataURL('image/jpeg');                    link.click();                };                qrContainer.appendChild(downloadBtn);            }            btnPrev.onclick = () => {                if (currentIndex > 0) {                    currentIndex--;                    updateQR(currentIndex);                }            };            btnNext.onclick = () => {                if (currentIndex < chunks.length - 1) {                    currentIndex++;                    updateQR(currentIndex);                }            };            closeBtn.onclick = () => modal.remove();            // Initial QR update            updateQR(currentIndex);        }    });</script><script>    // Constants    const DEFAULT_PROXY_BANK_URL = 'https://raw.githubusercontent.com/jaka2m/botak/refs/heads/main/cek/proxyList.txt';    const PROXY_CHECK_API_URL = 'https://cors.checker-ip.web.id/?url=https://api.checker-ip.web.id/check';    const PATH_PREFIX = 'Geo-Project'; // Hardcoded path prefix    const MainDomains = [        'joss.checker-ip.xyz',        'vpn.checker-ip.web.id'    ];    const CustomBugs = [];        // Safe base64 encoding function    function safeBase64Encode(str) {        try {            // Make sure we're working with a string            const stringToEncode = typeof str === 'object' ? JSON.stringify(str) : String(str);            return window.btoa(stringToEncode);        } catch (e) {            console.error("Base64 encoding error:", e);            return "";        }    }        // Check if proxy is valid via APIasync function checkProxyValidity(ip, port) {    try {        const response = await fetch(`${PROXY_CHECK_API_URL}?ip=${ip}:${port}`);                if (!response.ok) {            console.error(`API error: ${response.status}`);            return false;        }                const data = await response.json();        return data.status && data.status.toUpperCase() === "ACTIVE";    } catch (error) {        console.error("Error checking proxy:", error);        return false;    }}    // Create VMess config object    function createVMessConfig(uuid, domain, host, sni, proxyHost, proxyPort, countryCode, isp, tls) {    return {        v: "2",        ps: `${countryCode} - ${isp} [ VMESS - ${tls ? 'TLS' : 'NTLS'} ]`,        add: domain,        port: tls ? 443 : 80,        id: uuid,        aid: "0",        net: "ws",        type: "none",        scy: "zero",        host: host,        path: `/${PATH_PREFIX}/${proxyHost}-${proxyPort}`,        tls: tls ? "tls" : "none",        sni: sni,        fp: "randomized"    };}        // Format label with protocol and TLS info    function formatLabel(countryCode, isp, protocol, tls) {        return `${countryCode} - ${isp} [ ${protocol.toUpperCase()} - ${tls ? 'TLS' : 'NTLS'} ]`;    }    // Function to get country name from country code    function getCountryName(countryCode) {        return countryCode;    }    // Function to fetch and populate regions from GitHub    async function populateRegionsFromGitHub() {        try {            const response = await fetch(DEFAULT_PROXY_BANK_URL);            if (!response.ok) {                throw new Error(`Failed to fetch proxy data: ${response.status}`);            }                        const proxyList = (await response.text()).split('\n').filter(Boolean);                        // Extract unique country codes            const uniqueCountryCodes = new Set();                        proxyList.forEach(line => {                const parts = line.split(',');                if (parts.length >= 3) {                    const countryCode = parts[2];                    if (countryCode) {                        uniqueCountryCodes.add(countryCode);                    }                }            });                        // Sort country codes alphabetically            const sortedCountryCodes = [...uniqueCountryCodes].sort();                        // Get the country select element            const countrySelect = document.getElementById('country');                        // Keep the default options            const defaultOptions = `                <option value="">GLOBAL (ALL)</option>                <option value="random">RANDOM</option>            `;                        // Add the country codes from GitHub with their names            let regionOptions = '';            sortedCountryCodes.forEach(code => {                regionOptions += `<option value="${code}">${code}</option>`;            });                        // Update the select element            countrySelect.innerHTML = defaultOptions + regionOptions;                        console.log(`Successfully loaded ${sortedCountryCodes.length} regions from GitHub`);        } catch (error) {            console.error("Error loading regions:", error);        }    }    // Generate Clash YAML for VLESSfunction generateClashVLESS(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {    return `- name: ${name}  server: ${domain}  port: ${tls ? 443 : 80}  type: vless  uuid: ${uuid}  cipher: auto  tls: ${tls}  udp: false  skip-cert-verify: true  network: ws  servername: ${sni}  ws-opts:    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}    headers:      Host: ${host}`;}// Generate Clash YAML for Trojanfunction generateClashTrojan(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {    return `- name: ${name}  server: ${domain}  port: ${tls ? 443 : 80}  type: trojan  password: ${uuid}  udp: false  skip-cert-verify: true  network: ws  sni: ${sni}  ws-opts:    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}    headers:      Host: ${host}`;}// Generate Clash YAML for Shadowsocksfunction generateClashSS(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {    return `- name: ${name}  server: ${domain}  port: ${tls ? 443 : 80}  type: ss  cipher: none  password: ${uuid}  plugin: v2ray-plugin  client-fingerprint: chrome  udp: false  plugin-opts:    mode: websocket    host: ${host}    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}    tls: ${tls}    mux: false    skip-cert-verify: true  headers:    custom: value    ip-version: dual    v2ray-http-upgrade: false    v2ray-http-upgrade-fast-open: false`;}// Generate Clash YAML for VMessfunction generateClashVMess(name, uuid, domain, host, sni, proxyHost, proxyPort, tls) {    return `- name: ${name}  server: ${domain}  port: ${tls ? 443 : 80}  type: vmess  uuid: ${uuid}  alterId: 0  cipher: zero  tls: ${tls}  skip-cert-verify: true  servername: ${sni}  network: ws  ws-opts:    path: /${PATH_PREFIX}/${proxyHost}-${proxyPort}    headers:      Host: ${host}  udp: true`;}// Generate Singbox configurationfunction generateSingboxConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {    const ports = tls ? '443' : '80';    const snio = tls ? `\n      "tls": {\n        "enabled": true,\n        "server_name": "${sni}",\n        "insecure": true\n      },` : '';        let config = '';    if (type === 'vless') {        config = `    {      "type": "vless",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "uuid": "${uuid}",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        },        "early_data_header_name": "Sec-WebSocket-Protocol"      },      "packet_encoding": "xudp"    }`;    } else if (type === 'vmess') {        config = `    {      "type": "vmess",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "uuid": "${uuid}",      "alter_id": 0,      "security": "zero",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        },        "early_data_header_name": "Sec-WebSocket-Protocol"      },      "packet_encoding": "xudp"    }`;    } else if (type === 'trojan') {        config = `    {      "type": "trojan",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "password": "${uuid}",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        },        "early_data_header_name": "Sec-WebSocket-Protocol"      }    }`;    } else if (type === 'ss') {        config = `    {      "type": "shadowsocks",      "tag": "${name}",      "server": "${domain}",      "server_port": 443,      "method": "none",      "password": "${uuid}",      "plugin": "v2ray-plugin",      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"    }`;    }        return config;}// Generate Singbox configurationfunction generateSingboxxlConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {    const ports = tls ? '443' : '80';    const snio = tls ? `\n      "tls": {\n        "enabled": true,\n        "server_name": "${sni}",\n        "insecure": true\n      },` : '';        let config = '';    if (type === 'vless') {        config = `    {      "type": "vless",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "uuid": "${uuid}",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        }      },      "domain_strategy": "ipv4_only"    }`;    } else if (type === 'vmess') {        config = `    {      "type": "vmess",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "uuid": "${uuid}",      "alter_id": 0,      "security": "zero",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        }      },      "domain_strategy": "ipv4_only"    }`;    } else if (type === 'trojan') {        config = `    {      "type": "trojan",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "password": "${uuid}",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        }      },      "domain_strategy": "ipv4_only"    }`;    } else if (type === 'ss') {        config = `    {      "type": "shadowsocks",      "tag": "${name}",      "server": "${domain}",      "server_port": 443,      "method": "none",      "password": "${uuid}",      "plugin": "v2ray-plugin",      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"    }`;    }        return config;}// Generate Nekobox configurationfunction generateNekoboxConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {    const ports = tls ? '443' : '80';    const snio = tls ? `\n      "tls": {\n        "disable_sni": false,\n        "enabled": true,\n        "insecure": true,\n        "server_name": "${sni}"\n      },` : '';        let config = '';    if (type === 'vless') {        config = `    {      "domain_strategy": "ipv4_only",      "flow": "",      "multiplex": {        "enabled": false,        "max_streams": 32,        "protocol": "smux"      },      "packet_encoding": "xudp",      "server": "${domain}",      "server_port": ${ports},      "tag": "${name}",${snio}      "transport": {        "early_data_header_name": "Sec-WebSocket-Protocol",        "headers": {          "Host": "${host}"        },        "max_early_data": 0,        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "type": "ws"      },      "type": "vless",      "uuid": "${uuid}"    }`;    } else if (type === 'trojan') {        config = `    {      "domain_strategy": "ipv4_only",      "multiplex": {        "enabled": false,        "max_streams": 32,        "protocol": "smux"      },      "password": "${uuid}",      "server": "${domain}",      "server_port": ${ports},      "tag": "${name}",${snio}      "transport": {        "early_data_header_name": "Sec-WebSocket-Protocol",        "headers": {          "Host": "${host}"        },        "max_early_data": 0,        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "type": "ws"      },      "type": "trojan"    }`;    } else if (type === 'vmess') {        config = `    {      "domain_strategy": "ipv4_only",      "multiplex": {        "enabled": false,        "max_streams": 32,        "protocol": "smux"      },      "packet_encoding": "xudp",      "server": "${domain}",      "server_port": ${ports},      "tag": "${name}",${snio}      "transport": {        "early_data_header_name": "Sec-WebSocket-Protocol",        "headers": {          "Host": "${host}"        },        "max_early_data": 0,        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "type": "ws"      },      "type": "vmess",      "uuid": "${uuid}",      "alter_id": 0,      "security": "zero"    }`;    } else if (type === 'ss') {        config = `    {      "type": "shadowsocks",      "tag": "${name}",      "server": "${domain}",      "server_port": 443,      "method": "none",      "password": "${uuid}",      "plugin": "v2ray-plugin",      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"    }`;    }        return config;}function generatehusiConfig(name, uuid, domain, host, sni, proxyHost, proxyPort, tls, type) {    const ports = tls ? '443' : '80';    const snio = tls ? `\n      "tls": {\n        "enabled": true,\n        "server_name": "${sni}",\n        "insecure": true\n      },` : '';        let config = '';    if (type === 'vless') {        config = `    {      "type": "vless",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "uuid": "${uuid}",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        },        "early_data_header_name": "Sec-WebSocket-Protocol"      },      "packet_encoding": "xudp"    }`;    } else if (type === 'vmess') {        config = `    {      "type": "vmess",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "uuid": "${uuid}",      "alter_id": 0,      "security": "zero",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        },        "early_data_header_name": "Sec-WebSocket-Protocol"      },      "packet_encoding": "xudp"    }`;    } else if (type === 'trojan') {        config = `    {      "type": "trojan",      "tag": "${name}",      "domain_strategy": "ipv4_only",      "server": "${domain}",      "server_port": ${ports},      "password": "${uuid}",${snio}      "multiplex": {        "protocol": "smux",        "max_streams": 32      },      "transport": {        "type": "ws",        "path": "/${PATH_PREFIX}/${proxyHost}-${proxyPort}",        "headers": {          "Host": "${host}"        },        "early_data_header_name": "Sec-WebSocket-Protocol"      }    }`;    } else if (type === 'ss') {        config = `    {      "type": "shadowsocks",      "tag": "${name}",      "server": "${domain}",      "server_port": 443,      "method": "none",      "password": "${uuid}",      "plugin": "v2ray-plugin",      "plugin_opts": "mux=0;path=/${PATH_PREFIX}/${proxyHost}-${proxyPort};host=${host};tls=${tls ? '1' : '0'}"    }`;    }        return config;}// Main Functionconst usedProxies = new Set();async function generateV2raySub(type, uuid, bugType, mainDomain, customBugs, tls, validateProxies, formatType, country = null, limit = 9999) {    try {        const response = await fetch(`${DEFAULT_PROXY_BANK_URL}?_=${Date.now()}`);        if (!response.ok) {            throw new Error(`Failed to fetch proxy data: ${response.status}`);        }        const proxyList = (await response.text()).split('\n').filter(Boolean);        let filteredProxies = proxyList;        if (country) {            filteredProxies = proxyList.filter(line => {                const parts = line.split(',');                return parts.length >= 3 && parts[2]?.toUpperCase() === country.toUpperCase();            });        }        if (filteredProxies.length === 0) {            throw new Error("No proxies found matching your region criteria");        }        filteredProxies = filteredProxies.sort(() => Math.random() - 0.5);        // Apply limit after shuffle (limit default: 9999)        let limitedProxies = filteredProxies.slice(0, parseInt(limit));        const firstBug = customBugs && customBugs.length > 0 ? customBugs[0] : null;        let domain, host, sni;                switch (bugType) {            case 'default':                domain = mainDomain;                host = mainDomain;                sni = mainDomain;                break;            case 'non-wildcard':                domain = firstBug || mainDomain;                host = mainDomain;                sni = mainDomain;                break;            case 'wildcard':                domain = firstBug || mainDomain;                host = `${firstBug}.${mainDomain}`;                sni = `${firstBug}.${mainDomain}`;                break;        }        const results = [];        let validProxies = [];                // Check proxy validity if enabled        if (validateProxies) {            // Show validation status UI            document.getElementById('validation-status').style.display = 'block';            document.getElementById('loading').style.display = 'none';                        // Initialize validation UI            const validationBar = document.getElementById('validation-bar');            const validationCount = document.getElementById('validation-count');            const validCountEl = document.getElementById('valid-count');            const invalidCountEl = document.getElementById('invalid-count');                        validationBar.style.width = '0%';            validationCount.textContent = `0/${limitedProxies.length}`;            validCountEl.textContent = '0';            invalidCountEl.textContent = '0';                        // Prepare validation tasks in batches to avoid overwhelming the browser            const BATCH_SIZE = 10;            let validCount = 0;            let invalidCount = 0;            let processedCount = 0;                        // Process proxies in batches            for (let i = 0; i < limitedProxies.length; i += BATCH_SIZE) {                const batch = limitedProxies.slice(i, i + BATCH_SIZE);                const batchPromises = batch.map(async (line) => {                    const parts = line.split(',');                    if (parts.length < 3) {                        return { line, isValid: false };                    }                                        const [proxyHost, proxyPort] = parts;                    const isValid = await checkProxyValidity(proxyHost, proxyPort);                    return { line, isValid };                });                                const batchResults = await Promise.all(batchPromises);                                for (const result of batchResults) {                    processedCount++;                                        if (result.isValid) {                        validCount++;                        validProxies.push(result.line);                    } else {                        invalidCount++;                    }                                        if (processedCount % 3 === 0 || processedCount === limitedProxies.length) {                        requestAnimationFrame(() => {                            const percentage = (processedCount / limitedProxies.length) * 100;                            validationBar.style.width = `${percentage}%`;                            validationCount.textContent = `${processedCount}/${limitedProxies.length}`;                            validCountEl.textContent = validCount;                            invalidCountEl.textContent = invalidCount;                        });                    }                }            }                        if (validProxies.length === 0) {                if (parseInt(limit) <= 5) {                    console.log("No valid proxies found, using unvalidated ones");                    validProxies = limitedProxies.slice(0, parseInt(limit));                } else {                    throw new Error("No valid proxies found");                }            }            document.getElementById('validation-status').style.display = 'none';            document.getElementById('loading').style.display = 'block';            if (validProxies.length < parseInt(limit)) {                const allValidatedHosts = new Set(limitedProxies.map(line => line.split(',')[0]));                const newProxies = proxyList.filter(line => {                    const host = line.split(',')[0];                    return !allValidatedHosts.has(host) && !usedProxies.has(`${host}:${line.split(',')[1]}`);                });                                const neededCount = parseInt(limit) - validProxies.length;                const additionalProxies = newProxies.slice(0, neededCount);                                limitedProxies = [...validProxies, ...additionalProxies];                limitedProxies = limitedProxies.slice(0, parseInt(limit));            } else {                limitedProxies = validProxies.slice(0, parseInt(limit));            }        }                // Mark proxies as used before generating configs        limitedProxies.forEach(line => {            const [host, port] = line.split(',');            usedProxies.add(`${host}:${port}`);        });        // Rest of your original config generation code remains the same...        // For Clash format        if (formatType === 'clash') {            let allProxies = [];                        for (let i = 0; i < limitedProxies.length; i++) {                const line = limitedProxies[i];                const parts = line.split(',');                if (parts.length < 3) continue;                                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;                const isp = ispParts.join(' ') || 'Unknown';                                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];                                for (const bug of bugsToUse) {                    let bugDomain, bugHost, bugSni;                                        switch (bugType) {                        case 'default':                            bugDomain = mainDomain;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'non-wildcard':                            bugDomain = bug;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'wildcard':                            bugDomain = bug;                            bugHost = `${bug}.${mainDomain}`;                            bugSni = `${bug}.${mainDomain}`;                            break;                    }                                        const bugLabel = bug !== mainDomain ? `[${bug}]` : '';                    const name = `${countryCode} - ${isp} ${bugLabel} ${i+1}`;                                        switch (type) {                        case 'vless':                            allProxies.push(generateClashVLESS(`${name}-[VLESS-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            break;                        case 'vmess':                            allProxies.push(generateClashVMess(`${name}-[VMESS-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            break;                        case 'trojan':                            allProxies.push(generateClashTrojan(`${name}-[TROJAN-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            break;                        case 'shadowsocks':                            allProxies.push(generateClashSS(`${name}-[SS-${tls ? 'TLS' : 'NTLS'}]`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            break;                        case 'mix':                            const mixIndex = i + 1;                            allProxies.push(generateClashVLESS(`${countryCode} - ${isp} ${bugLabel}-[VLESS-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.1`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            allProxies.push(generateClashTrojan(`${countryCode} - ${isp} ${bugLabel}-[TROJAN-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.2`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            allProxies.push(generateClashSS(`${countryCode} - ${isp} ${bugLabel}-[SS-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.3`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            allProxies.push(generateClashVMess(`${countryCode} - ${isp} ${bugLabel}-[VMESS-${tls ? 'TLS' : 'NTLS'}] ${mixIndex}.4`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls));                            break;                    }                }            }                        return `#Geo-Project\nproxies:\n${allProxies.join('\n')}`;        }          // For Singbox format        else if (formatType === 'singbox') {            let allProxies = [];            let proxyTags = [];                        for (let i = 0; i < limitedProxies.length; i++) {                const line = limitedProxies[i];                const parts = line.split(',');                if (parts.length < 3) continue;                                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;                const isp = ispParts.join(' ') || 'Unknown';                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();                                // If we have multiple bugs, create configs for each bug                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];                                for (const bug of bugsToUse) {                    // Determine domain, host, and SNI for this specific bug                    let bugDomain, bugHost, bugSni;                                        switch (bugType) {                        case 'default':                            bugDomain = mainDomain;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'non-wildcard':                            bugDomain = bug;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'wildcard':                            bugDomain = bug;                            bugHost = `${bug}.${mainDomain}`;                            bugSni = `${bug}.${mainDomain}`;                            break;                    }                                        const bugLabel = bug !== mainDomain ? `[${bug}]` : '';                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;                                        switch (type) {                        case 'vmess':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            break;                        case 'vless':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            break;                        case 'trojan':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            break;                        case 'shadowsocks':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateSingboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                        case 'mix':                            proxyTags.push(`        "${name} vmess",`);                            proxyTags.push(`        "${name} vless",`);                            proxyTags.push(`        "${name} trojan",`);                            proxyTags.push(`        "${name} ss",`);                            allProxies.push(generateSingboxConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            allProxies.push(generateSingboxConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            allProxies.push(generateSingboxConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            allProxies.push(generateSingboxConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                    }                }            }                        // Remove trailing comma from the last proxy            if (allProxies.length > 0) {                const lastProxy = allProxies[allProxies.length - 1];                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');            }                        // Create the full Singbox configuration            return `#### GEO PROJECT #### {  "log": {    "level": "info"  },  "dns": {    "servers": [      {        "tag": "remote-dns",        "address": "https://family.cloudflare-dns.com/dns-query",        "address_resolver": "direct-dns",        "strategy": "ipv4_only"      },      {        "tag": "direct-dns",        "address": "local",        "strategy": "ipv4_only"      },      {        "tag": "dns-final",        "address": "local",        "address_resolver": "dns-local",        "strategy": "ipv4_only"      },      {        "tag": "dns-local",        "address": "local"      },      {        "tag": "dns-block",        "address": "rcode://success"      }    ],    "rules": [      {        "domain": [          "family.cloudflare-dns.com",          "${domain}"        ],        "server": "direct-dns"      }    ],    "final": "dns-final",    "independent_cache": true  },  "inbounds": [    {      "type": "tun",      "mtu": 1400,      "inet4_address": "172.19.0.1/30",      "inet6_address": "fdfe:dcba:9876::1/126",      "auto_route": true,      "strict_route": true,      "endpoint_independent_nat": true,      "stack": "mixed",      "sniff": true    }  ],  "outbounds": [    {      "tag": "Internet",      "type": "selector",      "outbounds": [        "Best Latency",${proxyTags.join('\n')}        "direct"      ]    },    {      "type": "urltest",      "tag": "Best Latency",      "outbounds": [${proxyTags.join('\n')}        "direct"      ],      "url": "https://ping.wildcrd.us.kg",      "interval": "30s"    },${allProxies.join(',\n')},    {      "type": "direct",      "tag": "direct"    },    {      "type": "direct",      "tag": "bypass"    },    {      "type": "block",      "tag": "block"    },    {      "type": "dns",      "tag": "dns-out"    }  ],  "route": {    "rules": [      {        "port": 53,        "outbound": "dns-out"      },      {        "inbound": "dns-in",        "outbound": "dns-out"      },      {        "network": "udp",        "port": 443,        "outbound": "block"      },      {        "source_ip_cidr": [          "224.0.0.0/3",          "ff00::/8"        ],        "ip_cidr": [          "224.0.0.0/3",          "ff00::/8"        ],        "outbound": "block"      }    ],    "auto_detect_interface": true  },  "experimental": {    "cache_file": {      "enabled": false    },    "clash_api": {      "external_controller": "127.0.0.1:9090",      "external_ui": "ui",      "external_ui_download_url": "https://github.com/MetaCubeX/metacubexd/archive/gh-pages.zip",      "external_ui_download_detour": "Internet",      "secret": "geo",      "default_mode": "rule"    }  }}`;        }                // For Singbox format        else if (formatType === 'singboxxl') {            let allProxies = [];            let proxyTags = [];                        for (let i = 0; i < limitedProxies.length; i++) {                const line = limitedProxies[i];                const parts = line.split(',');                if (parts.length < 3) continue;                                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;                const isp = ispParts.join(' ') || 'Unknown';                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();                                // If we have multiple bugs, create configs for each bug                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];                                for (const bug of bugsToUse) {                    // Determine domain, host, and SNI for this specific bug                    let bugDomain, bugHost, bugSni;                                        switch (bugType) {                        case 'default':                            bugDomain = mainDomain;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'non-wildcard':                            bugDomain = bug;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'wildcard':                            bugDomain = bug;                            bugHost = `${bug}.${mainDomain}`;                            bugSni = `${bug}.${mainDomain}`;                            break;                    }                                        const bugLabel = bug !== mainDomain ? `[${bug}]` : '';                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;                                        switch (type) {                        case 'vmess':                            proxyTags.push(`        "${name}"`);                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            break;                        case 'vless':                            proxyTags.push(`        "${name}"`);                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            break;                        case 'trojan':                            proxyTags.push(`        "${name}"`);                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            break;                        case 'shadowsocks':                            proxyTags.push(`        "${name}"`);                            allProxies.push(generateSingboxxlConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                        case 'mix':                            proxyTags.push(`        "${name} vmess"`);                            proxyTags.push(`        "${name} vless"`);                            proxyTags.push(`        "${name} trojan"`);                            proxyTags.push(`        "${name} ss"`);                            allProxies.push(generateSingboxxlConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            allProxies.push(generateSingboxxlConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            allProxies.push(generateSingboxxlConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            allProxies.push(generateSingboxxlConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                    }                }            }                        // Remove trailing comma from the last proxy            if (allProxies.length > 0) {                const lastProxy = allProxies[allProxies.length - 1];                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');            }                        // Create the full Singbox configuration            return `#### GEO PROJECT #### {  "log": {    "level": "panic"  },  "dns": {    "servers": [      {        "tag": "remote",        "address": [          "tls://223.5.5.5",          "tls://223.6.6.6"        ]      },      {        "tag": "local",        "address": [          "112.215.203.246",          "112.215.203.247",          "112.215.203.248",          "112.215.203.254",          "112.215.198.248",          "112.215.198.254"        ],        "detour": "direct"      }    ],    "rules": [      {        "outbound": "any",        "server": "local"      }    ],    "strategy": "prefer_ipv4"  },  "inbounds": [    {      "type": "tun",      "interface_name": "tun0",      "mtu": 1400,      "address": "172.19.0.1/30",      "auto_route": true,      "stack": "gvisor",      "sniff": true    },    {      "type": "mixed",      "listen": "0.0.0.0",      "listen_port": 2080,      "sniff": true    }  ],  "outbounds": [    {      "type": "selector",      "tag": "GLOBAL",      "outbounds": [${proxyTags.join(',' + '\n')}      ]    },    {      "type": "urltest",      "tag": "AUTO",      "outbounds": [${proxyTags.join(',' + '\n')}      ],         "url": "https://www.google.com",         "interval": "10s",         "tolerance": 50    },${allProxies.join(',\n')},    {      "type": "direct",      "tag": "direct"    },    {      "type": "block",      "tag": "block"    },    {      "type": "dns",      "tag": "dns-out"    }  ],  "route": {    "rules": [      {        "protocol": "dns",        "outbound": "dns-out"      },      {        "network": "udp",        "port": [443, 3478, 500, 4500],        "outbound": "block"      }    ],    "auto_detect_interface": true  },  "experimental": {    "cache_file": {      "enabled": true,       "path": "cache.db"    },    "clash_api": {      "external_controller": "0.0.0.0:9090",      "external_ui": "dashboard"    }  }}`;        }        // For Nekobox format        else if (formatType === 'nekobox') {            let allProxies = [];            let proxyTags = [];                        for (let i = 0; i < limitedProxies.length; i++) {                const line = limitedProxies[i];                const parts = line.split(',');                if (parts.length < 3) continue;                                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;                const isp = ispParts.join(' ') || 'Unknown';                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();                                // If we have multiple bugs, create configs for each bug                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];                                for (const bug of bugsToUse) {                    // Determine domain, host, and SNI for this specific bug                    let bugDomain, bugHost, bugSni;                                        switch (bugType) {                        case 'default':                            bugDomain = mainDomain;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'non-wildcard':                            bugDomain = bug;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'wildcard':                            bugDomain = bug;                            bugHost = `${bug}.${mainDomain}`;                            bugSni = `${bug}.${mainDomain}`;                            break;                    }                                        const bugLabel = bug !== mainDomain ? `[${bug}]` : '';                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;                                        switch (type) {                        case 'vless':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            break;                        case 'vmess':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            break;                        case 'trojan':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            break;                        case 'shadowsocks':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generateNekoboxConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                        case 'mix':                            proxyTags.push(`        "${name} vless",`);                            proxyTags.push(`        "${name} vmess",`);                            proxyTags.push(`        "${name} trojan",`);                            proxyTags.push(`        "${name} ss",`);                            allProxies.push(generateNekoboxConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            allProxies.push(generateNekoboxConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            allProxies.push(generateNekoboxConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            allProxies.push(generateNekoboxConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                    }                }            }                        // Remove trailing comma from the last proxy            if (allProxies.length > 0) {                const lastProxy = allProxies[allProxies.length - 1];                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');            }                        // Create the full Nekobox configuration            return `#### GEO PROJECT #### {  "dns": {    "final": "dns-final",    "independent_cache": true,    "rules": [      {        "disable_cache": false,        "domain": [          "family.cloudflare-dns.com",          "${domain}"        ],        "server": "direct-dns"      }    ],    "servers": [      {        "address": "https://family.cloudflare-dns.com/dns-query",        "address_resolver": "direct-dns",        "strategy": "ipv4_only",        "tag": "remote-dns"      },      {        "address": "local",        "strategy": "ipv4_only",        "tag": "direct-dns"      },      {        "address": "local",        "address_resolver": "dns-local",        "strategy": "ipv4_only",        "tag": "dns-final"      },      {        "address": "local",        "tag": "dns-local"      },      {        "address": "rcode://success",        "tag": "dns-block"      }    ]  },  "experimental": {    "cache_file": {      "enabled": true,      "path": "../cache/clash.db",      "store_fakeip": true    },    "clash_api": {      "external_controller": "127.0.0.1:9090",      "external_ui": "../files/yacd"    }  },  "inbounds": [    {      "listen": "0.0.0.0",      "listen_port": 6450,      "override_address": "8.8.8.8",      "override_port": 53,      "tag": "dns-in",      "type": "direct"    },    {      "domain_strategy": "",      "endpoint_independent_nat": true,      "inet4_address": [        "172.19.0.1/28"      ],      "mtu": 9000,      "sniff": true,      "sniff_override_destination": true,      "stack": "system",      "tag": "tun-in",      "type": "tun"    },    {      "domain_strategy": "",      "listen": "0.0.0.0",      "listen_port": 2080,      "sniff": true,      "sniff_override_destination": true,      "tag": "mixed-in",      "type": "mixed"    }  ],  "log": {    "level": "info"  },  "outbounds": [    {      "outbounds": [        "Best Latency",${proxyTags.join('\n')}        "direct"      ],      "tag": "Internet",      "type": "selector"    },    {      "interval": "1m0s",      "outbounds": [${proxyTags.join('\n')}        "direct"      ],      "tag": "Best Latency",      "type": "urltest",      "url": "https://detectportal.firefox.com/success.txt"    },${allProxies.join(',\n')},    {      "tag": "direct",      "type": "direct"    },    {      "tag": "bypass",      "type": "direct"    },    {      "tag": "block",      "type": "block"    },    {      "tag": "dns-out",      "type": "dns"    }  ],  "route": {    "auto_detect_interface": true,    "rules": [      {        "outbound": "dns-out",        "port": [          53        ]      },      {        "inbound": [          "dns-in"        ],        "outbound": "dns-out"      },      {        "network": [          "udp"        ],        "outbound": "block",        "port": [          443        ],        "port_range": []      },      {        "ip_cidr": [          "224.0.0.0/3",          "ff00::/8"        ],        "outbound": "block",        "source_ip_cidr": [          "224.0.0.0/3",          "ff00::/8"        ]      }    ]  }}`;}else if (formatType === 'husi') {            let allProxies = [];            let proxyTags = [];                        for (let i = 0; i < limitedProxies.length; i++) {                const line = limitedProxies[i];                const parts = line.split(',');                if (parts.length < 3) continue;                                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;                const isp = ispParts.join(' ') || 'Unknown';                const sanitizedIsp = isp.replace(/[\n\r]+/g, "").trim();                                // If we have multiple bugs, create configs for each bug                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];                                for (const bug of bugsToUse) {                    // Determine domain, host, and SNI for this specific bug                    let bugDomain, bugHost, bugSni;                                        switch (bugType) {                        case 'default':                            bugDomain = mainDomain;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'non-wildcard':                            bugDomain = bug;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'wildcard':                            bugDomain = bug;                            bugHost = `${bug}.${mainDomain}`;                            bugSni = `${bug}.${mainDomain}`;                            break;                    }                                        const bugLabel = bug !== mainDomain ? `[${bug}]` : '';                    const name = `(${countryCode}) ${sanitizedIsp} ${bugLabel} ${i+1}`;                                        switch (type) {                        case 'vmess':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            break;                        case 'vless':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            break;                        case 'trojan':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            break;                        case 'shadowsocks':                            proxyTags.push(`        "${name}",`);                            allProxies.push(generatehusiConfig(name, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                        case 'mix':                            proxyTags.push(`        "${name} vmess",`);                            proxyTags.push(`        "${name} vless",`);                            proxyTags.push(`        "${name} trojan",`);                            proxyTags.push(`        "${name} ss",`);                            allProxies.push(generatehusiConfig(`${name} vmess`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vmess'));                            allProxies.push(generatehusiConfig(`${name} vless`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'vless'));                            allProxies.push(generatehusiConfig(`${name} trojan`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'trojan'));                            allProxies.push(generatehusiConfig(`${name} ss`, uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, tls, 'ss'));                            break;                    }                }            }                        // Remove trailing comma from the last proxy            if (allProxies.length > 0) {                const lastProxy = allProxies[allProxies.length - 1];                allProxies[allProxies.length - 1] = lastProxy.replace(/,\s*$/, '');            }                        // Create the full husi configuration            return `#### GEO PROJECT #### {  "dns": {    "final": "dns-final",    "independent_cache": true,    "rules": [      {        "disable_cache": false,        "domain": [          "family.cloudflare-dns.com",          "${domain}"        ],        "server": "direct-dns"      }    ],    "servers": [      {        "address": "https://family.cloudflare-dns.com/dns-query",        "address_resolver": "direct-dns",        "strategy": "ipv4_only",        "tag": "remote-dns"      },      {        "address": "local",        "strategy": "ipv4_only",        "tag": "direct-dns"      },      {        "address": "local",        "address_resolver": "dns-local",        "strategy": "ipv4_only",        "tag": "dns-final"      },      {        "address": "local",        "tag": "dns-local"      },      {        "address": "rcode://success",        "tag": "dns-block"      }    ]  },  "experimental": {    "cache_file": {      "enabled": true,      "path": "../cache/cache.db",      "store_fakeip": true    },    "clash_api": {      "external_controller": "127.0.0.1:9090"    },    "v2ray_api": {      "listen": "127.0.0.1:0",      "stats": {        "enabled": true,        "outbounds": [          "proxy",          "direct"        ]      }    }  },  "inbounds": [    {      "listen": "0.0.0.0",      "listen_port": 6450,      "override_address": "8.8.8.8",      "override_port": 53,      "tag": "dns-in",      "type": "direct"    },    {      "domain_strategy": "",      "endpoint_independent_nat": true,      "inet4_address": [        "172.19.0.1/28"      ],      "mtu": 9000,      "sniff": true,      "sniff_override_destination": true,      "stack": "system",      "tag": "tun-in",      "type": "tun"    },    {      "domain_strategy": "",      "listen": "0.0.0.0",      "listen_port": 2080,      "sniff": true,      "sniff_override_destination": true,      "tag": "mixed-in",      "type": "mixed"    }  ],  "log": {    "level": "info"  },  "outbounds": [    {      "outbounds": [        "Best Latency",        ${proxyTags.join('\n')}        "direct"      ],      "tag": "Internet",      "type": "selector"    },    {      "interval": "1m0s",      "outbounds": [        ${proxyTags.join('\n')}        "direct"      ],      "tag": "Best Latency",      "type": "urltest",      "url": "https://detectportal.firefox.com/success.txt"    },    ${allProxies.join(',\n')},    {      "tag": "direct",      "type": "direct"    },    {      "tag": "bypass",      "type": "direct"    },    {      "tag": "block",      "type": "block"    },    {      "tag": "dns-out",      "type": "dns"    }  ],  "route": {    "auto_detect_interface": true,    "rules": [      {        "outbound": "dns-out",        "port": [          53        ]      },      {        "inbound": [          "dns-in"        ],        "outbound": "dns-out"      },      {        "network": [          "udp"        ],        "outbound": "block",        "port": [          443        ],        "port_range": []      },      {        "ip_cidr": [          "224.0.0.0/3",          "ff00::/8"        ],        "outbound": "block",        "source_ip_cidr": [          "224.0.0.0/3",          "ff00::/8"        ]      }    ]  }}`;        }        // V2Ray format - process each proxy individually        else {            for (const line of limitedProxies) {                const parts = line.split(',');                if (parts.length < 3) continue;                                const [proxyHost, proxyPort, countryCode, ...ispParts] = parts;                const isp = ispParts.join(' ') || 'Unknown';                                // If we have multiple bugs, create configs for each bug                const bugsToUse = customBugs && customBugs.length > 0 ? customBugs : [mainDomain];                                for (const bug of bugsToUse) {                    // Determine domain, host, and SNI for this specific bug                    let bugDomain, bugHost, bugSni;                                        switch (bugType) {                        case 'default':                            bugDomain = mainDomain;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'non-wildcard':                            bugDomain = bug;                            bugHost = mainDomain;                            bugSni = mainDomain;                            break;                        case 'wildcard':                            bugDomain = bug;                            bugHost = `${bug}.${mainDomain}`;                            bugSni = `${bug}.${mainDomain}`;                            break;                    }                                        let config;                    // Remove bugLabel for V2Ray format                                        switch (type) {                        case 'vless':                             const vlessLabel = formatLabel(countryCode, isp, 'VLESS', tls);                            config = `vless://${uuid}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(vlessLabel)}`;                            break;                                                case 'vmess':                             const vmessConfig = createVMessConfig(uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, countryCode, isp, tls);                            const vmessString = JSON.stringify(vmessConfig);                            config = `vmess://${safeBase64Encode(vmessString)}`;                            break;                                                case 'trojan':                             const trojanLabel = formatLabel(countryCode, isp, 'TROJAN', tls);                            config = `trojan://${uuid}@${bugDomain}:${tls ? 443 : 80}?security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(trojanLabel)}`;                            break;                                                case 'shadowsocks':                             const ssLabel = formatLabel(countryCode, isp, 'SS', tls);                            const ssAuth = `none:${uuid}`;                            config = `ss://${safeBase64Encode(ssAuth)}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(ssLabel)}`;                            break;                                                case 'mix':                             // For mix, we'll create all protocol types with appropriate labels                            const vmessConfigMix = createVMessConfig(uuid, bugDomain, bugHost, bugSni, proxyHost, proxyPort, countryCode, isp, tls);                            const vmessStringMix = JSON.stringify(vmessConfigMix);                                                        const vlessLabelMix = formatLabel(countryCode, isp, 'VLESS', tls);                            const trojanLabelMix = formatLabel(countryCode, isp, 'TROJAN', tls);                            const ssLabelMix = formatLabel(countryCode, isp, 'SS', tls);                                                        const ssAuthMix = `none:${uuid}`;                            config = [                                `vless://${uuid}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(vlessLabelMix)}`,                                `vmess://${safeBase64Encode(vmessStringMix)}`,                                `trojan://${uuid}@${bugDomain}:${tls ? 443 : 80}?security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(trojanLabelMix)}`,                                `ss://${safeBase64Encode(ssAuthMix)}@${bugDomain}:${tls ? 443 : 80}?encryption=none&security=${tls ? 'tls' : 'none'}&type=ws&host=${bugHost}&path=%2F${PATH_PREFIX}%2F${proxyHost}-${proxyPort}&sni=${bugSni}#${encodeURIComponent(ssLabelMix)}`                            ].join('\n');                            break;                    }                                        if (config) {                        results.push(config);                    }                }            }                        return results.join('\n');        }    } catch (error) {        console.error("Error generating subscription:", error);        throw error;    }}        // UI Interaction    document.addEventListener('DOMContentLoaded', () => {        // Populate regions from GitHub when the page loads        populateRegionsFromGitHub();        // Populate main domains from the constant array        const mainDomainSelect = document.getElementById('mainDomain');        MainDomains.forEach(domain => {            const option = document.createElement('option');            option.value = domain;            option.textContent = domain;            mainDomainSelect.appendChild(option);        });            const form = document.getElementById('subLinkForm');        const loadingEl = document.getElementById('loading');        const resultEl = document.getElementById('result');        const outputEl = document.getElementById('output');        const copyLinkBtn = document.getElementById('copyLink');        const errorMessageEl = document.getElementById('error-message');        const generateUuidBtn = document.getElementById('generateUuid');        const uuidInput = document.getElementById('uuid');        const bugTypeSelect = document.getElementById('bugType');        const customBugContainer = document.getElementById('customBugContainer');        const validationStatusEl = document.getElementById('validation-status');                // Show/hide custom bug field based on bug type        bugTypeSelect.addEventListener('change', () => {            if (bugTypeSelect.value === 'default') {                customBugContainer.style.display = 'none';            } else {                customBugContainer.style.display = 'block';            }        });                // Form submission handler        form.addEventListener('submit', async (e) => {            e.preventDefault();                        const type = document.getElementById('configType').value;            const uuid = document.getElementById('uuid').value.trim();            const bugType = document.getElementById('bugType').value;            const mainDomain = document.getElementById('mainDomain').value;                        // Parse comma-separated custom bugs            const customBugInput = document.getElementById('customBug').value.trim();            const selectedBugs = customBugInput ? customBugInput.split(',').map(bug => bug.trim()) : [];                        const tls = document.getElementById('tls').value === 'true';            const country = document.getElementById('country').value.trim() || null;            const limit = document.getElementById('limit').value.trim() || null;            const validateProxies = document.getElementById('validateProxies').checked;            const formatType = document.getElementById('formatType').value;                        // Validation            if (!uuid || !mainDomain) {                errorMessageEl.textContent = 'ERROR: UUID and Main Domain are required';                return;            }                        if ((bugType === 'non-wildcard' || bugType === 'wildcard') && selectedBugs.length === 0) {                errorMessageEl.textContent = 'ERROR: At least one Custom Bug is required for Non-Wildcard and Wildcard modes';                return;            }                        try {                // Reset UI                validationStatusEl.style.display = 'none';                resultEl.style.display = 'none';                errorMessageEl.textContent = '';                                // Update loading text based on validation setting                const loadingTextEl = document.querySelector('.loading-text');                loadingTextEl.textContent = validateProxies ?                     'Fetching proxy data and preparing to validate...' :                     'Fetching proxy data and generating configs...';                                // Show loading                loadingEl.style.display = 'block';                                // Generate subscription                const result = await generateV2raySub(                    type, uuid, bugType, mainDomain, selectedBugs, tls, validateProxies, formatType, country, limit                );                                // Hide loading                loadingEl.style.display = 'none';                                // Display result                outputEl.value = result;                resultEl.style.display = 'block';            } catch (error) {                loadingEl.style.display = 'none';                validationStatusEl.style.display = 'none';                errorMessageEl.textContent = 'ERROR: ' + error.message;                console.error(error);            }        });                // Copy functionality        copyLinkBtn.addEventListener('click', () => {            outputEl.select();            document.execCommand('copy');                        const originalText = copyLinkBtn.textContent;            copyLinkBtn.textContent = ' COPIED SUCCESSFULLY';            copyLinkBtn.style.background = 'linear-gradient(90deg, var(--color-success), var(--color-success))';                        setTimeout(() => {                copyLinkBtn.textContent = originalText;                copyLinkBtn.style.background = 'linear-gradient(90deg, var(--color-success), var(--color-primary))';            }, 2000);        });    });</script></body></html>